<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>比特币白皮书(多语言版本)</title>
      <link href="/posts/f0cde75.html"/>
      <url>/posts/f0cde75.html</url>
      
        <content type="html"><![CDATA[<p>We have proposed a system for electronic transactions without relying on trust. We started with the usual framework of coins made from digital signatures, which provides strong control of ownership, but is incomplete without a way to prevent double-spending. To solve this, we proposed a peer-to-peer network using proof-of-work to record a public history of transactions that quickly becomes computationally impractical for an attacker to change if honest nodes control a majority of CPU power. The network is robust in its unstructured simplicity. Nodes work all at once with little coordination. They do not need to be identified, since messages are not routed to any particular place and only need to be delivered on a best effort basis. Nodes can leave and rejoin the network at will, accepting the proof-of-work chain as proof of what happened while they were gone. They vote with their CPU power, expressing their acceptance of valid blocks by working on extending them and rejecting invalid blocks by refusing to work on them. Any needed rules and incentives can be enforced with this consensus mechanism.</p><p>我们提出了一个不必依赖信任的电子交易系统；起点是一个普通的使用数字签名的硬币框架开始，虽然它提供了健壮的所有权控制，却无法避免双重支付。为了解决这个问题，我们提出一个使用工作证明机制的点对点网络去记录一个公开的交易记录历史，只要诚实节点能够控制大多数 CPU 算力，那么攻击者就仅从算力方面就不可能成功篡改系统。这个网络的健壮在于它的无结构的简单。节点们可以在很少协同的情况下瞬间同时工作。它们甚至不需要被辨认，因为消息的路径并非取决于特定的终点；消息只需要被以最大努力为基本去传播即可。节点来去自由，重新加入时，只需要接受工作证明链，作为它们离线之时所发生之一切的证明。它们通过它们的 CPU 算力投票，通过不断为链添加新的有效区块、拒绝无效区块，去表示它们对有效交易的接受与否。任何必要的规则和奖励都可以通过这个共识机制来强制实施。</p><p>详细链接：<br><a href="https://bitcoin.org/en/bitcoin-paper" target="_blank" rel="noopener">比特币白皮书(多语言版本)</a><br><a href="https://github.com/xiaolai/bitcoin-whitepaper-chinese-translation/blob/master/Bitcoin-Whitepaper-EN-CN.md" target="_blank" rel="noopener">比特币白皮书(中英文对照版)</a></p>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 比特币 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTTP/HTTPS 协议简记</title>
      <link href="/posts/a5f5efd1.html"/>
      <url>/posts/a5f5efd1.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-HTTP-1-x"><a href="#1-HTTP-1-x" class="headerlink" title="1.HTTP 1.x"></a>1.HTTP 1.x</h3><p><strong>HTTP 请求构建</strong></p><p>浏览器将域名发送给 DNS 服务器，让它解析为 IP 地址。HTTP 是基于 TCP 协议的，所以要先建立 TCP 连接（三次握手四次挥手）。<br>HTTP 报文分为三大部分：请求行，首部，正文实体。</p><p>请求行中常用的请求方法有几种类型：</p><ul><li>GET 去服务器获取资源。</li><li>POST 发送信息给服务器。</li><li>PUT 向指定资源上传最新内容。</li><li>DELETE 删除资源。</li><li>还有 HEAD TRACE OPTIONS CONNECT 其他请求方法。</li></ul><p>首部（请求报头）字段是以 key value 通过冒号分隔。（Accept-Charset，Content-Type，Cache-control 等）</p><p><strong>HTTP 返回构建</strong></p><ul><li>在接收和解释请求消息后，服务器返回一个HTTP响应消息。</li><li>HTTP响应也是由三个部分组成，分别是：状态行、消息报头、响应正文</li></ul><p><strong>HTTP/1.x 的缺陷</strong></p><p>HTTP是建立在TCP协议之上，所以瓶颈在TCP协议本身：</p><ul><li>连接无法复用：导致每次请求都经历三次握手和慢启动。</li><li>Head-Of-Line Blocking（HOLB）：导致带宽无法被充分利用，以及后续健康请求被阻塞。</li><li>协议开销大：header里携带的内容过大，在一定程度上增加了传输的成本，并且每次请求header基本不怎么变化，尤其在移动端增加用户流量。</li><li>安全因素：内容明文传输，客户端和服务器端都无法验证对方的身份，这在一定程度上无法保证数据的安全性。</li></ul><h3 id="2-HTTP-2-0"><a href="#2-HTTP-2-0" class="headerlink" title="2.HTTP 2.0"></a>2.HTTP 2.0</h3><p>因为HTTP/1.x的问题，我们会引入雪碧图、将小图内联、使用多个域名等等的方式来提高性能。不过这些优化都绕开了协议，直到谷歌的 SPDY 协议，主要解决HTTP/1.1效率不高的问题。降低延迟，压缩header等等，最终带来HTTP/2的诞生。</p><ul><li>HTTP 2.0 的头进行一定的压缩，将原来每次都要携带的大量 key value 在两端建立一个索引表，对相同的头只发送索引表中的索引。</li><li>HTTP 2.0 还将所有的传输信息分割为更小的消息和帧，并对它们采用二进制格式编码。</li><li>HTTP 2.0 其实是将三个请求变成三个流，将数据分成帧乱序发送到一个 TCP 连接中。</li><li>HTTP 2.0 成功解决了 HTTP 1.1 的队首阻塞问题。</li><li>HTTP 2.0 新特性：二进制传输，多路复用，Header 压缩，Server Push 。（<a href="https://http2.akamai.com/demo" target="_blank" rel="noopener">多路复用</a>）</li></ul><h3 id="3-HTTP-3-0"><a href="#3-HTTP-3-0" class="headerlink" title="3.HTTP 3.0"></a>3.HTTP 3.0</h3><h4 id="QUIC-新功能"><a href="#QUIC-新功能" class="headerlink" title="QUIC 新功能"></a>QUIC 新功能</h4><p>由于TCP与丢包问题，Google 搞了一个基于 UDP 协议的 QUIC 协议，在原本的基础上新增了很多功能，并且使用在了 HTTP/3 上。</p><p><strong>0-RTT</strong><br>通过使用类似 TCP 快速打开的技术，缓存当前会话的上下文，在下次恢复会话的时候，只需要将之前的缓存传递给服务端验证通过就可以进行传输了。0RTT 建连可以说是 QUIC 相比 HTTP2 最大的性能优势。传输层(加密层) 0RTT 就能建立（加密）连接。<br>由于建立在 UDP 的基础上，同时又实现了 0RTT 的安全握手，所以在大部分情况下，只需要 0 个 RTT 就能实现数据发送，在实现前向加密的基础上，并且 0RTT 的成功率相比 TLS 的会话记录单要高。</p><p><strong>多路复用</strong><br>与HTTP2.0一样，同一条 QUIC连接上可以创建多个stream，来发送多个HTTP请求，但QUIC是基于UDP的，一个连接上的多个stream之间没有依赖。无需等待，就可以发给用户。</p><p><strong>加密认证的报文</strong><br>TCP 协议头部没有经过任何加密和认证，所以在传输过程中很容易被中间网络设备篡改、注入和窃听。比如修改序列号、滑动窗口。这些行为有可能是出于性能优化，也有可能是主动攻击。<br>除了个别报文比如 PUBLIC_RESET 和 CHLO，所有报文头部都是经过认证的，报文 Body 都是经过加密的。<br>这样只要对 QUIC 报文任何修改，接收端都能够及时发现，有效地降低了安全风险。</p><p><strong>向前纠错机制</strong><br>每个数据包除了它本身的内容之外，还包括了部分其他数据包的数据，因此少量的丢包可以通过其他包的冗余数据直接组装而无需重传。<br>向前纠错牺牲了每个数据包可以发送数据的上限，但是减少了因为丢包导致的数据重传，因为数据重传将会消耗更多的时间(包括确认数据包丢失、请求重传、等待新数据包等步骤的时间消耗)。<br>假如说这次我要发送三个包，那么协议会算出这三个包的异或值并单独发出一个校验包，也就是总共发出了四个包。当出现其中的非校验包丢包的情况时，可以通过另外三个包计算出丢失的数据包的内容。当然这种技术只能使用在丢失一个包的情况下，如果出现丢失多个包就不能使用纠错机制了，只能使用重传的方式了。</p><h3 id="4-HTTPS-协议"><a href="#4-HTTPS-协议" class="headerlink" title="4.HTTPS 协议"></a>4.HTTPS 协议</h3><p>HTTP 协议通信使用明文（不加密），内容可能会被窃听 不验证通信方的身份，因此有可能遭遇伪装 无法证明报文的完整性，内容可能被篡改。</p><h4 id="加密与数字证书"><a href="#加密与数字证书" class="headerlink" title="加密与数字证书"></a>加密与数字证书</h4><p>对称加密算法中，使用的密钥是相同的。在互联网应用中，用户太多，这样是不行。<br>非对称加密算法中，使用的密钥是不相同的。客户端与服务器分别用对方的公钥加密，用自己的私钥解密。<br>非对称加密的问题在于如何将公钥传给对方，这时就需要权威部门介入，颁发数字证书。<br>数字证书的签名算法，取得信息的Hash值(不可逆)，加密Hash值，签名与信息一起发出去。<br>你从访问的网站得到一个证书，从证书发布机构CA得到公钥，再用公钥解密证书签名。<br>确定CA公钥的可靠性，CA通过上级证书层层授信背书到 root CA，保证了非对称加密正常运转。</p><h4 id="HTTPS的工作模式"><a href="#HTTPS的工作模式" class="headerlink" title="HTTPS的工作模式"></a>HTTPS的工作模式</h4><p>这是HTTPS协议的总体思路：</p><p><img src="/images/7f7eaaf382hf8fh388f8e38ff8.jpg" alt="7f7eaaf382hf8fh388f8e38ff8.jpg"></p><p>总结：</p><ul><li>HTTP1.x 有连接无法复用、队头阻塞、协议开销大和安全因素等多个缺陷。</li><li>HTTP2 通过多路复用、二进制流、Header 压缩等技术，极大地提高了性能，但是还是存在着问题。</li><li>QUIC 基于 UDP 实现，是 HTTP3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议。</li></ul><p>Reference：<br><a href="https://github.com/i5ting/oh-http" target="_blank" rel="noopener">https://github.com/i5ting/oh-http</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript Dom 事件模型</title>
      <link href="/posts/b180c941.html"/>
      <url>/posts/b180c941.html</url>
      
        <content type="html"><![CDATA[<h4 id="1-事件模型"><a href="#1-事件模型" class="headerlink" title="1.事件模型"></a>1.事件模型</h4><p>DOM 事件级别:<br>DOM0 element.onclick=function(){}<br>DOM1 标准没有涉及事件的提案。<br>DOM2 element.addEventListener(‘click’,function(){},false)<br>DOM3 element.addEventListener(‘keyup’,function(){},false) //增加了更多类型</p><p>事件模型：捕获(上到下)， 冒泡(下到上)<br>事件流： 捕获 目标阶段 冒泡<br>描述 DOM 事件捕获的具体流程：window -&gt; document -&gt; html -&gt; body -&gt; … -&gt; 目标元素/ev。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *event: 字符串，指定事件名</span></span><br><span class="line"><span class="comment"> *function: 指定要事件触发时执行的函数</span></span><br><span class="line"><span class="comment"> *useCapture: 布尔值，指定事件是否在捕获或冒泡阶段执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//事件监听</span></span><br><span class="line">element.addEventListener(event, <span class="function"><span class="keyword">function</span>, <span class="title">useCapture</span>)</span></span><br><span class="line"><span class="function">//移除事件监听：</span></span><br><span class="line"><span class="function"><span class="title">element</span>.<span class="title">removeEventListener</span>(<span class="params">event, function, useCapture</span>)</span></span><br><span class="line"><span class="function">//<span class="title">IE8</span> 及更早（目标阶段-冒泡阶段）</span></span><br><span class="line"><span class="function">//事件监听：</span></span><br><span class="line"><span class="function"><span class="title">element</span>.<span class="title">attatchEvent</span>(<span class="params">event, function</span>)</span></span><br><span class="line"><span class="function">//移除事件监听：</span></span><br><span class="line"><span class="function"><span class="title">element</span>.<span class="title">detachEvent</span>(<span class="params">event, function</span>)</span></span><br></pre></td></tr></table></figure><h4 id="2-事件对象"><a href="#2-事件对象" class="headerlink" title="2.事件对象"></a>2.事件对象</h4><p>DOM事件模型中的事件对象常用属性:</p><ol><li>type // 用于获取事件类型</li><li>target // 获取事件目标(当前被点击的元素)</li><li>stopPropagation() // 阻止事件冒泡</li><li>preventDefault() // 阻止默认事件</li><li>currentTarget //当前绑定的事件 </li><li>stopImmediatePropagation() //A中阻止B执行(事件响应优先级)</li></ol><p>IE事件模型中的事件对象常用属性:</p><ol><li>type // 用于获取事件类型</li><li>srcElement //获取事件目标</li><li>cancelBubble //阻止事件冒泡</li><li>returnValue //阻止事件默认行为</li></ol><h4 id="3-事件委托-代理"><a href="#3-事件委托-代理" class="headerlink" title="3.事件委托/代理"></a>3.事件委托/代理</h4><p>优势：</p><ul><li>省内存减少事件注册,</li><li>新增子对象时无需再次对其绑定事件，适合动态添加元素</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>one<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>two<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>three<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">//父元素</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> dom = <span class="built_in">document</span>.getElementById(<span class="string">'parent'</span>);</span></span><br><span class="line"><span class="javascript">  <span class="comment">//父元素绑定事件，代理子元素的点击事件</span></span></span><br><span class="line"><span class="javascript">  dom.onclick= <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> event= event || <span class="built_in">window</span>.event;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> curTarget= event.target || event.srcElement;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (curTarget.tagName.toLowerCase() == <span class="string">'li'</span>) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">//事件处理</span></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-实现事件模型"><a href="#4-实现事件模型" class="headerlink" title="4.实现事件模型"></a>4.实现事件模型</h4><p>编写 bind 绑定，trigger 触发函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Emitter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//_listener[自定义的事件名]= [所用执行的匿名函数1，所用执行的匿名函数2,...]</span></span><br><span class="line">    <span class="keyword">this</span>._listener= []; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Emitter.prototype.bind= <span class="function"><span class="keyword">function</span>(<span class="params">eventName, handle</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//是否存在eventName事件，否则新建数组</span></span><br><span class="line">    <span class="keyword">var</span> listener= <span class="keyword">this</span>._listener[eventName] || []; </span><br><span class="line">    listener.push(handle);</span><br><span class="line">    <span class="keyword">this</span>._listener[eventName]= listener; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Emitter.prototype.trigger= <span class="function"><span class="keyword">function</span>(<span class="params">eventName</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//取得除eventName之外的其他参数</span></span><br><span class="line">    <span class="keyword">var</span> args= <span class="built_in">Array</span>.prototype.slice.apply(<span class="built_in">arguments</span>).slice(<span class="number">1</span>); </span><br><span class="line">    <span class="keyword">var</span> listener= <span class="keyword">this</span>._listener[eventName];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(listener)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//遍历事件</span></span><br><span class="line">    listener.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">handleFun</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            handleFun.apply(<span class="keyword">this</span>, args);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (e)&#123;</span><br><span class="line">            <span class="built_in">console</span>.error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例</span></span><br><span class="line"><span class="keyword">var</span> emitter= <span class="keyword">new</span> Emitter();</span><br><span class="line"><span class="comment">// 绑定函数</span></span><br><span class="line">emitter.bind(<span class="string">'output'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">arguments_1, arguments_2</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arguments_1, arguments_2);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//触发函数</span></span><br><span class="line">emitter.trigger(<span class="string">'output'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>);</span><br></pre></td></tr></table></figure><h4 id="5-事件广播"><a href="#5-事件广播" class="headerlink" title="5.事件广播"></a>5.事件广播</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义事件</span></span><br><span class="line"><span class="keyword">var</span> event= <span class="keyword">new</span> Event(<span class="string">'custome'</span>); </span><br><span class="line">element.addEvenetListener(<span class="string">'custome'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;...&#125;, <span class="literal">false</span>);</span><br><span class="line">element.dispatchEvent(event);</span><br><span class="line"><span class="comment">// CustomEvent 区别：CustomEvent 后加 object 指定一些数据，参数自定义</span></span><br></pre></td></tr></table></figure><p>Reference：<br><a href="https://javascript.ruanyifeng.com/dom/event.html" target="_blank" rel="noopener">https://javascript.ruanyifeng.com/dom/event.html</a><br><a href="https://www.cnblogs.com/pcd12321/p/5223347.html" target="_blank" rel="noopener">https://www.cnblogs.com/pcd12321/p/5223347.html</a><br><a href="https://segmentfault.com/a/1190000006934031#articleHeader10" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006934031#articleHeader10</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Creating_and_triggering_events" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Creating_and_triggering_events</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript 模块加载的相关规范</title>
      <link href="/posts/fa0f8e99.html"/>
      <url>/posts/fa0f8e99.html</url>
      
        <content type="html"><![CDATA[<h4 id="CommonJS-规范"><a href="#CommonJS-规范" class="headerlink" title="CommonJS 规范"></a>CommonJS 规范</h4><p>定义的模块分为3部分: require(引用)， exports(导出)， module(本身)。规定一个文件就是一个模块，文件中定义的变量、函数、类，都是私有的，其他文件是不可见。加载模块是同步的，所以只有加载完成才能执行后面的操作。但如果是浏览器环境，要从服务器加载模块，这是就必须采用异步模式。所以就有了 AMD  CMD 等解决方案。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    <span class="string">"a"</span>:a,</span><br><span class="line">    <span class="string">"b"</span>:b</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.export = a <span class="comment">//模块导出</span></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./a.js'</span>) <span class="comment">//模块引入</span></span><br></pre></td></tr></table></figure></p><h4 id="ES6-Module"><a href="#ES6-Module" class="headerlink" title="ES6 Module"></a>ES6 Module</h4><p>使用 export 定义了对外接口，其他文件通过 import 加载这个模块，export 命令可以出现在模块的任何位置，只要处于模块顶层就可以。<br>import 命令具有提升效果，会提升到整个模块的头部，首先执行。由于 import 是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; foo <span class="keyword">as</span> myFoo &#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;<span class="comment">// 接口改名</span></span><br><span class="line"><span class="keyword">export</span> &#123; es6 <span class="keyword">as</span> <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">'./someModule'</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> es6 &#125; <span class="keyword">from</span> <span class="string">'./someModule'</span>;</span><br></pre></td></tr></table></figure></p><p>ES6默认就是严格模式，严格模式主要有以下限制：</p><ul><li>变量必须声明后再使用</li><li>函数的参数不能有同名属性，否则报错</li><li>不能使用with语句</li><li>不能对只读属性赋值，否则报错</li><li>不能使用前缀 0 表示八进制数，否则报错</li><li>不能删除不可删除的属性，否则报错</li><li>不能删除变量 delete prop，会报错，只能删除属性 delete global[prop]</li><li>eval 不会在它的外层作用域引入变量</li><li>eval 和 arguments 不能被重新赋值</li><li>arguments 不会自动反映函数参数的变化</li><li>不能使用 arguments.callee</li><li>不能使用 arguments.caller</li><li>禁止 this 指向全局对象</li><li>不能使用 fn.caller和fn.arguments 获取函数调用的堆栈</li><li>增加了保留字（比如protected、static和interface）</li></ul><p><strong>Module 的加载实现</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"./foo.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 等同于 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"./foo.js"</span> <span class="attr">defer</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><ul><li>代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。</li><li>模块脚本自动采用严格模式，不管有没有声明 use strict。</li><li>模块之中，可以使用 import命令 加载其他模块（.js后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用 export 命令输出对外接口。</li><li>模块之中，顶层的 this 关键字返回 undefined，而不是指向 window。也就是说，在模块顶层使用 this 关键字，是无意义的。</li><li>同一个模块如果加载多次，将只执行一次。</li></ul><p>ES6 模块与 CommonJS 模块的差异以及如何处理”循环加载”：</p><ul><li>CommonJS 模块输出的是一个<strong>值的拷贝</strong>，ES6 模块输出的是<strong>值的引用</strong>。CommonJS 模块是<strong>运行时</strong>加载，ES6 模块是<strong>编译时</strong>输出接口。</li><li>ES6 模块是动态引用，如果使用 import 从一个模块加载变量（即import foo from ‘foo’），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。CommonJS 模块代码在require的时候，就会全部执行。一旦出现某个模块被”循环加载”，<strong>就只输出已经执行的部分</strong>，还未执行的部分不会输出。</li></ul><h4 id="AMD-规范"><a href="#AMD-规范" class="headerlink" title="AMD 规范"></a>AMD 规范</h4><p>异步加载模块，适用define方法定义模块，运行时核心思想是「Early Executing」，也就是提前执行依赖。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// define</span></span><br><span class="line"><span class="comment">// id: 模块标识，可省。</span></span><br><span class="line"><span class="comment">// dependencies: 所依赖的模块，可省。</span></span><br><span class="line"><span class="comment">// factory: 模块的实现，或者一个JavaScript对象。   </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//a.js 只有factory</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        mix: <span class="function"><span class="keyword">function</span>(<span class="params">source, target</span>) </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//b.js 依赖a.js</span></span><br><span class="line">define([<span class="string">'a'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        show: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//c.js 依赖a.js b.js</span></span><br><span class="line">define([<span class="string">'a'</span>, <span class="string">'b'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//d.js 对象模块</span></span><br><span class="line">define(&#123;</span><br><span class="line">    data1: [],</span><br><span class="line">    data2: []</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>AMD规范允许输出模块兼容CommonJS规范，这时define方法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> reqModule = <span class="built_in">require</span>(<span class="string">"./a.js"</span>);</span><br><span class="line">    requModule.mix();</span><br><span class="line">    exports.asplode = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h4 id="CMD-规范"><a href="#CMD-规范" class="headerlink" title="CMD 规范"></a>CMD 规范</h4><p>CMD 和 AMD 的区别:对于依赖的模块AMD是提前执行，CMD是延迟执行。不过RequireJS从2.0开始，也改成可以延迟执行(根据写法不同，处理方式不通过),CMD依赖就近，AMD依赖前置。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AMD写法</span></span><br><span class="line">define([<span class="string">'./a'</span>,<span class="string">'./b'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//依赖一开始就写好</span></span><br><span class="line">    a.mix();</span><br><span class="line">    b.show();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//CMD写法</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">requie, exports, module</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//依赖可以就近书写</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</span><br><span class="line">    a.mix();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (...) &#123;</span><br><span class="line">        <span class="keyword">var</span> b = requie(<span class="string">'./b'</span>);</span><br><span class="line">        b.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h4 id="UMD-规范"><a href="#UMD-规范" class="headerlink" title="UMD 规范"></a>UMD 规范</h4><p>应用 UMD 规范的 js 文件其实就是一个立即执行函数。函数有两个参数，第一个参数是当前运行时环境，第二个参数是模块的定义体。在执行UMD规范时，会优先判断是当前环境是否支持AMD环境，然后再检验是否支持CommonJS环境，否则认为当前环境为浏览器环境（ window ）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">root, factory</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd) &#123;</span><br><span class="line">        <span class="comment">// AMD</span></span><br><span class="line">        define([<span class="string">'jquery'</span>], factory);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> exports === <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="comment">// Node, CommonJS-like</span></span><br><span class="line">        <span class="built_in">module</span>.exports = factory(<span class="built_in">require</span>(<span class="string">'jquery'</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Browser globals (root is window)</span></span><br><span class="line">        root.returnExports = factory(root.jQuery);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span> (<span class="params">$</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//    methods</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">myFunc</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">    <span class="comment">//    exposed public method</span></span><br><span class="line">    <span class="keyword">return</span> myFunc;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>Reference：<br><a href="https://segmentfault.com/a/1190000006232697" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006232697</a><br><a href="http://www.cnblogs.com/imwtr/p/4666181.html" target="_blank" rel="noopener">http://www.cnblogs.com/imwtr/p/4666181.html</a><br><a href="http://caibaojian.com/es6/module.html" target="_blank" rel="noopener">http://caibaojian.com/es6/module.html</a><br><a href="http://www.cnblogs.com/vs1435/p/6553139.html" target="_blank" rel="noopener">http://www.cnblogs.com/vs1435/p/6553139.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React diff 算法</title>
      <link href="/posts/4344ff3.html"/>
      <url>/posts/4344ff3.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>React 的 diff 算法作为 Virtual DOM 的加速器，其算法上的改进优化是 React 整个界面渲染的基础，以及性能提高的保障，同时也是 React 源码中最神秘、最不可思议的部分，本文从源码入手，深入剖析 React diff 的不可思议之处.</p><h3 id="2-传统-diff-算法"><a href="#2-传统-diff-算法" class="headerlink" title="2.传统 diff 算法"></a>2.传统 diff 算法</h3><p>传统 diff 算法的复杂度为 O(n^3)，显然这是无法满足性能要求的。React 通过制定大胆的策略，将 O(n^3) 复杂度的问题转换成 O(n) 复杂度的问题。</p><p>计算一棵树形结构转换成另一棵树形结构的最少操作，是一个复杂且值得研究的问题。传统 diff 算法通过循环递归对节点进行依次对比，效率低下，算法复杂度达到 O(n^3)，其中 n 是树中节点的总数。O(n^3) 到底有多可怕，这意味着如果要展示1000个节点，就要依次执行上十亿次的比较。这种指数型的性能消耗对于前端渲染场景来说代价太高了！现今的 CPU 每秒钟能执行大约30亿条指令，即便是最高效的实现，也不可能在一秒内计算出差异情况。</p><h3 id="3-详解-React-diff"><a href="#3-详解-React-diff" class="headerlink" title="3.详解 React diff"></a>3.详解 React diff</h3><h4 id="diff-策略"><a href="#diff-策略" class="headerlink" title="diff 策略"></a>diff 策略</h4><ol><li>Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。</li><li>拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。 </li><li>对于同一层级的一组子节点，它们可以通过唯一 id 进行区分。</li></ol><p>基于以上三个前提策略，React 分别对 tree diff、component diff 以及 element diff 进行算法优化，事实也证明这三个前提策略是合理且准确的，它保证了整体界面构建的性能。</p><h4 id="tree-diff"><a href="#tree-diff" class="headerlink" title="tree diff"></a>tree diff</h4><p>对两棵树进行分层比较，只会对同一层次的节点进行比较(同一个父节点下的所有子节点)。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不在进一步比较。对树进行一次遍历就完成了整个 DOM 树的比较。</p><p>当出现节点跨层级移动时，并不会出现移动操作，而是以 A 为根节点的树被整个重新创建，由于影响性能，官方不建议进行 DOM 节点跨层级的操作。</p><blockquote><p>注意：在开发组件时，保持稳定的 DOM 结构会有助于性能的提升。例如，可以通过 CSS 隐藏或显示节点，而不是真的移除或添加 DOM 节点。</p></blockquote><h4 id="component-diff"><a href="#component-diff" class="headerlink" title="component diff"></a>component diff</h4><ul><li>同一类型的组件，按原策略继续比较 virtual DOM tree。</li><li>不同类型的组件，则判断为 dirty component，替换整个组件下的所有子节点。</li><li>同一类型的组件，Virtual DOM 没有任何变化（如果知道），通过 shouldComponentUpdate() 来判断该组件是否需要进行 diff。</li></ul><p>如果结构相似但是不同类型的组件。就不会比较二者的结构，而是直接删除重建。（很少存在）</p><h4 id="element-diff"><a href="#element-diff" class="headerlink" title="element diff"></a>element diff</h4><p>当节点处于同一层级时，React diff 提供了三种节点操作，分别为：INSERT_MARKUP（插入）、MOVE_EXISTING（移动）和 REMOVE_NODE（删除）。</p><ul><li>插入：新的 component 类型不在老集合里， 即是全新的节点，对新节点执行插入操作。</li><li>移动：老集合有新 component 类型，且 element 是可更新的类型，generateComponentChildren 已调用 receiveComponent，这种情况下 prevChild=nextChild，就需要做移动操作，可以复用以前的 DOM 节点。</li><li>删除：老 component 类型，在新集合里也有，但对应的 element 不同则不能直接复用和更新，需要执行删除操作，或者老 component 不在新集合里的，也需要执行删除操作。</li></ul><p>新老集合进行 diff 差异化对比，通过 key 发现新老集合中的节点都是相同的节点，因此无需进行节点删除和创建，只需要将老集合中节点的位置进行移动，更新为新集合中节点的位置</p><blockquote><p>建议：在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作，当节点数量过大或更新操作过于频繁时，在一定程度上会影响 React 的渲染性能。</p></blockquote><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h3><ol><li>React 通过 diff 策略，将 O(n3) 复杂度的问题转换成 O(n) 复杂度的问题；</li><li>React 通过分层求异的策略，对 tree diff 进行算法优化；</li><li>React 通过相同类生成相似树形结构，不同类生成不同树形结构的策略，对 component diff 进行算法优化；</li><li>React 通过设置唯一 key的策略，对 element diff 进行算法优化；</li><li>建议，在开发组件时，保持稳定的 DOM 结构会有助于性能的提升；</li><li>建议，在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作，当节点数量过大或更新操作过于频繁时，在一定程度上会影响 React 的渲染性能。</li></ol><p>Reference：<br><a href="https://zhuanlan.zhihu.com/p/20346379" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/20346379</a><br><a href="https://calendar.perfplanet.com/2013/diff/" target="_blank" rel="noopener">https://calendar.perfplanet.com/2013/diff/</a><br><a href="https://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf" target="_blank" rel="noopener">https://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf</a><br><a href="https://reactjs.org/docs/reconciliation.html" target="_blank" rel="noopener">https://reactjs.org/docs/reconciliation.html</a><br><a href="https://github.com/livoras/blog/issues/13" target="_blank" rel="noopener">https://github.com/livoras/blog/issues/13</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo 中遇到的问题</title>
      <link href="/posts/a7c707e6.html"/>
      <url>/posts/a7c707e6.html</url>
      
        <content type="html"><![CDATA[<h4 id="1-文件无法删除"><a href="#1-文件无法删除" class="headerlink" title="1.文件无法删除"></a>1.文件无法删除</h4><p>不要直接修改文件名的大小写，否则会造成文件已经删除(public与source都没有了)，但浏览博客中依然会显示的情况。</p><p>解决方法：重建一个原文件，注意文件名大小写一定要相同，然后再删除一次就可以了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure></p><h4 id="2-分类数与标签数显示不正确"><a href="#2-分类数与标签数显示不正确" class="headerlink" title="2.分类数与标签数显示不正确"></a>2.分类数与标签数显示不正确</h4><p><a href="https://theme-next.iissnan.com/faqs.html" target="_blank" rel="noopener">https://theme-next.iissnan.com/faqs.html</a></p><h4 id="3-链接持久化"><a href="#3-链接持久化" class="headerlink" title="3.链接持久化"></a>3.链接持久化</h4><p><a href="https://zuiyu1818.cn/posts/Hexo_seourl.html" target="_blank" rel="noopener">https://zuiyu1818.cn/posts/Hexo_seourl.html</a></p><h4 id="4-其他"><a href="#4-其他" class="headerlink" title="4.其他"></a>4.其他</h4><p>猫猫2d动画插件：<br><a href="https://github.com/xiazeyu/live2d-widget-models" target="_blank" rel="noopener">https://github.com/xiazeyu/live2d-widget-models</a><br><a href="https://11.tt/posts/2018/how-to-play-with-live2d-on-hexo/" target="_blank" rel="noopener">https://11.tt/posts/2018/how-to-play-with-live2d-on-hexo/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 写作 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React 常见问题</title>
      <link href="/posts/f9bf1214.html"/>
      <url>/posts/f9bf1214.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-React组件划分"><a href="#1-React组件划分" class="headerlink" title="1.React组件划分"></a>1.React组件划分</h3><p>按职责划分: UI组件负责UI的呈现，容器组件负责管理数据和逻辑。UI组件嵌套在容器组件中，容器组件通过React-redux提供的connect方法拿到store中的数据。<br>组件设计原则:<br>1.高内聚低耦合（组件自身不依赖于其他组件，抽象可复用组件让使用者之间没有耦合关系）<br>2.周期性迭代（先整体后部分再颗粒化，尽可能抽象）<br>数据管理原则:<br>1.能计算得到状态就不要单独存储。<br>2.组件尽量没有状态，所需数据通过props获取。<br>具体使用可以参照如下链接:<br><a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_three_react-redux.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_three_react-redux.html</a></p><h3 id="2-React组件的生命周期"><a href="#2-React组件的生命周期" class="headerlink" title="2.React组件的生命周期"></a>2.React组件的生命周期</h3><p>Render阶段（暂停），Pre-commit阶段（可读），commit阶段（可用）<br>1.创建时:<br>constructor: 组件更新到页面前先创建出来<br>getDefaultProps: 获取实例的默认属性 (old)<br>getInitialState: 获取每个实例的初始化状态（old）<br>componentWillMount: 组件即将被装载、渲染到页面上<br>render: 组件在这里生成虚拟的DOM节点<br>componentDidMount: 组件真正在被装载之后可操作了（ajax等）<br>2.更新时:<br>getDerivedStateFromProps: 用外部的属性初始化一些内部的状态（16.3引入）<br>componentWillReceiveProps: 组件将要接收到属性的时候调用 （16.3被取代）<br>shouldComponentUpdate: 组件接受到新属性或者新状态的时候（可以返回false，接收数据后不更新，阻止render调用，后面的函数不会被继续执行了，可用于性能优化）<br>componentWillUpdate: 组件即将更新不能修改属性和状态<br>render: 组件重新描绘<br>getSnapshotBeforeUpdate: 例如获取滚动条滚动高度再减去,不动的效果（16.3引入）<br>componentDidUpdate: 组件已经更新<br>3.卸载时:<br>componentWillUnmount:组件即将销毁</p><h3 id="3-React性能优化方案"><a href="#3-React性能优化方案" class="headerlink" title="3.React性能优化方案"></a>3.React性能优化方案</h3><p>1.使用production版本<br>2.使用key来帮助React识别列表中所有子组件的最小变化。<br>3.重写shouldComponentUpdate来避免不必要的dom操作。(判断是否需要调用render方法重新描绘dom)<br>参考链接：<a href="https://segmentfault.com/a/1190000006254212" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006254212</a></p><h3 id="4-理解diff算法"><a href="#4-理解diff算法" class="headerlink" title="4.理解diff算法"></a>4.理解diff算法</h3><p>把树形结构按照层级分解，只比较同级元素。<br>给列表结构的每个单元添加唯一的key属性，方便比较。<br>React只会匹配相同tag class的component（这里面的class指的是组件的名字）<br>合并操作，调用component的setState方法的时候, React将其标记为dirty.到每一个事件循环结束,React检查所有标记dirty的component重新绘制。<br>选择性子树渲染。开发人员可以重写shouldComponentUpdate提高diff的性能。<br>参考链接：<a href="https://segmentfault.com/a/1190000000606216" target="_blank" rel="noopener">https://segmentfault.com/a/1190000000606216</a></p><h3 id="5-虚拟dom如何提高性能"><a href="#5-虚拟dom如何提高性能" class="headerlink" title="5.虚拟dom如何提高性能"></a>5.虚拟dom如何提高性能</h3><p>虚拟dom相当于在js和真实dom中间加了一个缓存，利用diff算法避免了没有必要的dom操作，从而提高性能。<br>步骤：<br>1.用对象结构表示DOM树的结构,然后用这个树构建一个真正的DOM树，插到文档当中。<br>2.当状态变更时，重新构造一棵新的对象树。用新的树和旧的树进行比较，记录两棵树差异。<br>3.把记录的差异应用到最开始构建的真正的DOM树上，视图就更新了。<br>参考链接：<a href="https://www.zhihu.com/question/29504639?sort=created" target="_blank" rel="noopener">https://www.zhihu.com/question/29504639?sort=created</a></p><h3 id="6-flux工作流程"><a href="#6-flux工作流程" class="headerlink" title="6.flux工作流程"></a>6.flux工作流程</h3><p>最大特点:”单向数据流”。<br>1.用户访问View<br>2.View发出用户的Action<br>3.Dispatcher收到Action，要求Store进行相应的更新<br>4.Store更新后，发出一个”change”事件<br>5.View 收到”change”事件后，更新页面<br>参考链接：<a href="http://www.ruanyifeng.com/blog/2016/01/flux.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/01/flux.html</a></p><h3 id="7-redux中间件"><a href="#7-redux中间件" class="headerlink" title="7.redux中间件"></a>7.redux中间件</h3><p>中间件提供第三方插件的模式，自定义拦截 action -&gt; reducer 的过程。<br>变为 action -&gt; middlewares -&gt; reducer 。<br>这种机制可以让我们改变数据流，实现如异步 action ，action 过滤，日志输出，异常报告等功能。<br>常见的中间件：<br>redux-logger：提供日志输出<br>redux-thunk：处理异步操作<br>redux-promise：处理异步操作，actionCreator的返回值是promise</p><h3 id="8-redux有什么缺点"><a href="#8-redux有什么缺点" class="headerlink" title="8.redux有什么缺点"></a>8.redux有什么缺点</h3><p>1.一个组件所需要的数据，必须由父组件传过来，而不能像flux中直接从store取。<br>2.当一个组件相关数据更新时，即使父组件不需要用到这个组件，父组件还是会重新render，可能会有效率影响，或者需要写复杂的shouldComponentUpdate进行判断。</p><h3 id="9-React项目中的脚手架"><a href="#9-React项目中的脚手架" class="headerlink" title="9.React项目中的脚手架"></a>9.React项目中的脚手架</h3><p>Mern：MERN是脚手架的工具，它可以很容易地使用MongoDB, Express, React and NodeJS生成同构JS应用。它最大限度地减少安装时间，并得到您使用的成熟技术来加速开发。<br>参考链接：<a href="http://www.open-open.com/lib/view/open1455953055292.html" target="_blank" rel="noopener">http://www.open-open.com/lib/view/open1455953055292.html</a></p><h3 id="11-在React当中Element和Component的区别？"><a href="#11-在React当中Element和Component的区别？" class="headerlink" title="11.在React当中Element和Component的区别？"></a>11.在React当中Element和Component的区别？</h3><p>简单地说，一个React Element描述了你想在屏幕上看到什么。换个说法就是，一个React Element是一些UI的对象表示。一个Read component是一个函数或一个类，它可以接受输入并返回一个React Element （通常是通过JSX，它被转化成一个createElement调用）。 </p><h3 id="12-可以选择性地传递给setstate的第二个参数是什么，它的目的是什么？"><a href="#12-可以选择性地传递给setstate的第二个参数是什么，它的目的是什么？" class="headerlink" title="12.可以选择性地传递给setstate的第二个参数是什么，它的目的是什么？"></a>12.可以选择性地传递给setstate的第二个参数是什么，它的目的是什么？</h3><p>一个回调函数，当setstate结束并re-rendered该组件时将被调用。一些没有说出来的东西是 setstate是异步的，这就是为什么它需要一个第二个回调函数。通常最好使用另一个生命周期方法，而不是依赖这个回调函数，但是很高兴知道它存在。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setstate( </span><br><span class="line">    &#123; <span class="attr">username</span> : <span class="string">'tylermcginnis33'</span> &#125; ,</span><br><span class="line">    ()=&gt; <span class="built_in">console</span>.log (<span class="string">'setstate has flnlshed and the component re-rende red.'</span>)</span><br><span class="line">    )</span><br></pre></td></tr></table></figure></p><p>这段代码有什么问题？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setstate ( ( prevstate , props ）=&gt; &#123; </span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">   Streak : prevstate.Streak + props.count</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>没问题。只是这种写法很少被使用，你也可以传递一个函数给setstate ，它接收到先前的状态和道具并返回一个新的状态，它不仅没有什么问题，而且如果您根据以前的状态（ state ）设置状态，推荐使用这种写法。</p><h3 id="13-为什么要使React-children-map-props-children-gt-而不是props-children-map-gt"><a href="#13-为什么要使React-children-map-props-children-gt-而不是props-children-map-gt" class="headerlink" title="13.为什么要使React.children.map(props.children,()=&gt;)而不是props.children.map(()=&gt;)"></a>13.为什么要使React.children.map(props.children,()=&gt;)而不是props.children.map(()=&gt;)</h3><p>因为不能保证props.children将是一个数组．<br>以此代码为例,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Parent&gt;</span><br><span class="line">    &lt;h1＞Welcome.&lt;/h1&gt;</span><br><span class="line">&lt;/Parent&gt;</span><br></pre></td></tr></table></figure></p><p>在父组件内部，如果我们尝试使用props.children.map映射孩子，则会抛出错误，因为props.children是一个对象，而不是一个数组。<br>如果有多个子元素React只会使props.children成为一个数组。就像下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Parent&gt;</span><br><span class="line">    &lt;h1＞Welcome.&lt;/h1&gt;</span><br><span class="line">    &lt;h2&gt;props.children will now be an array&lt;/h2&gt;</span><br><span class="line">&lt;/Parent&gt;</span><br></pre></td></tr></table></figure></p><p>这就是为什么你喜欢React.children.map,因为它的实现考虑到props.children可能是一个数组或一个对象。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>在浏览器中输入URL并按下回车之后发生了什么？</title>
      <link href="/posts/9692490d.html"/>
      <url>/posts/9692490d.html</url>
      
        <content type="html"><![CDATA[<h4 id="1-按下回车键"><a href="#1-按下回车键" class="headerlink" title="1.按下回车键"></a>1.按下回车键</h4><p>键盘控制器在得到码值13之后，将其编码用于传输。物理键盘或虚拟键盘传输按键信息。服务器监听键码值，把这个按键字符发送给窗口管理器，当前窗口使用有关图形API把文字打印在输入框内。</p><h4 id="2-解析URL"><a href="#2-解析URL" class="headerlink" title="2.解析URL"></a>2.解析URL</h4><p>浏览器通过 URL 使用的HTTP协议与请求的资源页地址。当协议或主机名不合法时浏览器传给默认的搜索引擎，转换非 ASCII 的 Unicode 字符（含有不是 a-z， A-Z，0-9， - 或者 . 的字符）。浏览器会对主机名部分非ASCII的字符使用 Punycode 编码。</p><h4 id="3-检查-HSTS-列表"><a href="#3-检查-HSTS-列表" class="headerlink" title="3.检查 HSTS 列表"></a>3.检查 HSTS 列表</h4><p>浏览器检查自带的“预加载 HSTS（HTTP严格传输安全）”列表，判断使用 HTTPS 或 HTTP 协议发送请求（可要求浏览器只使用 HTTPS 发送请求）。</p><h4 id="4-DNS-查询"><a href="#4-DNS-查询" class="headerlink" title="4.DNS 查询"></a>4.DNS 查询</h4><p>检查域名在浏览器缓存中？检查本地操作系统 hosts？发送 ARP（地址解析协议）广播子网内查询？查找本地 DNS 服务器？如果本地 DNS 服务器没有找到结果，它会发送一个递归查询请求，一层一层向高层 DNS 服务器做查询，直到查询到起始授权机构把结果返回。</p><h4 id="5-使用套接字"><a href="#5-使用套接字" class="headerlink" title="5.使用套接字"></a>5.使用套接字</h4><p>当浏览器得到了目标服务器的 IP 地址、端口号，这个请求首先被交给传输层，在传输层请求被封装成 TCP segment（目标端口会被加入头部），然后送往网络层（再加入一个 IP 头部），这个 TCP packet 进入链路层（再加入 frame 头部），TCP 封包已经准备好。通过以太网、WiFi、蜂窝方式进行传输，最终封包会到达管理本地子网的路由器。继续经过自治区域的边界路由器，最终到达目标服务器。</p><h4 id="6-TLS-握手（安全传输层协议）"><a href="#6-TLS-握手（安全传输层协议）" class="headerlink" title="6.TLS 握手（安全传输层协议）"></a>6.TLS 握手（安全传输层协议）</h4><p>客户端发送一个 ClientHello 消息到服务器端，消息中同时包含了它的 Transport Layer Security (TLS) 版本，可用的加密算法和压缩算法。<br>服务器端向客户端返回一个 ServerHello 消息，消息中包含了服务器端的TLS版本，服务器所选择的加密和压缩算法，以及数字证书认证机构（Certificate Authority，缩写 CA）签发的服务器公开证书，证书中包含了公钥。客户端会使用这个公钥加密接下来的握手过程，直到协商生成一个新的对称密钥。<br>客户端根据自己的信任CA列表，验证服务器端的证书是否可信。如果认为可信，客户端会生成一串伪随机数，使用服务器的公钥加密它。这串随机数会被用于生成新的对称密钥。<br>服务器端使用自己的私钥解密上面提到的随机数，然后使用这串随机数生成自己的对称主密钥。<br>客户端发送一个 Finished 消息给服务器端，使用对称密钥加密这次通讯的一个散列值。<br>服务器端生成自己的 hash 值，然后解密客户端发送来的信息，检查这两个值是否对应。如果对应，就向客户端发送一个 Finished 消息，也使用协商好的对称密钥加密。<br>从现在开始，接下来整个 TLS 会话都使用对称秘钥进行加密，传输应用层（HTTP）内容。</p><h4 id="7-HTTP-服务器请求处理"><a href="#7-HTTP-服务器请求处理" class="headerlink" title="7.HTTP 服务器请求处理"></a>7.HTTP 服务器请求处理</h4><p>服务器根据浏览器发送的 HTTP 头部包含的信息（例如包含了 Etag 头部），可以判断出浏览器缓存的新鲜度，返回这样的响应: 200 或 304。<br>在解析完 HTML 之后，浏览器和客户端会重复上面的过程，直至 HTML 页面引入的所有资源全部都获取完毕。<br>HTTPD 接收请求，拆分请求的参数（HTTP 请求方法、域名、请求路径/页面），URL 重写模块，如果匹配上的话，服务器会按照规则重写这个请求，根据请求信息获取相应的响应内容，服务器会使用指定的处理程序分析处理这个文件（例如PHP）。</p><h4 id="8-浏览器处理资源文件"><a href="#8-浏览器处理资源文件" class="headerlink" title="8.浏览器处理资源文件"></a>8.浏览器处理资源文件</h4><p>当服务器提供资源之后（HTML，CSS，JS，图片等），浏览器会执行解析（HTML，CSS，JS）和渲染（构建 DOM 树 -&gt; 渲染 -&gt; 布局 -&gt; 绘制）。</p><p><strong>HTML 与 CSS 解析</strong></p><ul><li>HTML 解析器对 HTML 文档进行解析，生成解析树（以 DOM 元素以及属性为节点的树）。HTML 解析算法，主要包含了两个阶段：标记化和树的构建。<br>解析完成后开始加载其他资源，此时文档为可交互 ，然后解析推迟模式的脚本，之后文档状态为完成，浏览器触发load事件。</li><li>根据CSS词法和句法 分析CSS文件和 style 标签包含的内容以及 style 属性的值，每个CSS文件都被解析成一个样式表对象（StyleSheet object），这个对象里包含了带有选择器的CSS规则，和对应CSS语法的对象。</li></ul><p><strong>页面渲染</strong></p><ul><li>通过DOM节点树创建“渲染树”，并计算每个节点的各个CSS样式值；</li><li>通过子节点属性值构建每个节点的坐标；</li><li>利用到最近页面渲染时计算出来的各个值，计算出各个层的最终位置，由GPU异步渲染，帧被送到Window Server。图形驱动软件会把任务分成多个部分，这样可以充分利用 GPU 强大的并行计算能力，用于在渲染过程中进行大量的浮点计算。</li></ul><h4 id="后期渲染与用户引发的处理"><a href="#后期渲染与用户引发的处理" class="headerlink" title="后期渲染与用户引发的处理"></a>后期渲染与用户引发的处理</h4><p>渲染结束后，浏览器根据某些时间机制运行 JavaScript 代码或与用户交互(在搜索栏输入关键字获得搜索建议)。也可能改变网页的内容和布局，产生又一轮渲染与绘制。</p><p>Reference：<br><a href="https://github.com/skyline75489/what-happens-when-zh_CN/blob/1276667b5144603bd8919501249ee50d19b43ff0/README.rst" target="_blank" rel="noopener">https://github.com/skyline75489/what-happens-when-zh_CN/blob/1276667b5144603bd8919501249ee50d19b43ff0/README.rst</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>GitFlow 协同工作流</title>
      <link href="/posts/1f4ce6dd.html"/>
      <url>/posts/1f4ce6dd.html</url>
      
        <content type="html"><![CDATA[<p>在真实的生产过程中，中心式协同工作流与功能分支协同工作流，还不能满足工作的要求。<br>这主要因为软件生产中会有各式各样的问题，并要面对不同的环境。我们要在不停地开发新代码的同时，维护线上的代码，于是，就有了下面这些需求。</p><ol><li>希望有一个干净的分支，上面是可以发布的代码，上面的改动永远都是可以发布到生产环境中的。这个分支上不能有中间开发过程中不可以上生产线的代码提交。</li><li>希望当代码达到可以上线的状态时，也就是在 alpha/beta release 时，在测试和交付的过程中，依然可以开发下一个版本的代码。</li><li>对于已经发布的代码，也会有一些 Bug-fix 的改动，不会将正在开发的代码提交到生产线上去。</li></ol><p>面对这些需求，前面的协同方式就不行了。因为我们不仅是要在整个团队中共享代码，更要管理好代码与环境的一致性。</p><p>为了解决这些问题，GitFlow 协同工作流就出来了。</p><p>GitFlow 协同工作流是由 Vincent Driessen 于 2010 年在 A successful Git branching model 这篇文章介绍给世人的。</p><p>这个协同工作流的核心思想如下图所示。<br><img src="/images/9cf4c9bc17bf11aa07d47f61d2137fca.png" alt="9cf4c9bc17bf11aa07d47f61d2137fca.png"></p><p>整个代码库中一共有五种分支。</p><ul><li>Master 主干分支，用作发布环境，上面的每一次提交都是可以发布的。</li><li>Feature 功能分支，用于开发功能，其对应的是开发环境。</li><li>Developer 开发分支，一旦功能开发完成，就向 Developer 分支合并，合并完成后，删除功能分支。这个分支对应的是集成测试环境。</li><li>Release 当 Developer 分支测试达到可以发布状态时，开出一个 Release 分支来，然后做发布前的准备工作。这个分支对应的是预发环境。之所以需要这个 Release 分支，是我们的开发可以继续向前，不会因为要发布而被 block 住而不能提交。</li><li>一旦 Release 分支上的代码达到可以上线的状态，那么需要把 Release 分支向 Master 分支和 Developer 分支同时合并，以保证代码的一致性。然后再把 Release 分支删除掉。</li><li>Hotfix 是用于处理生产线上代码的 Bug-fix，每个线上代码的 Bug-fix 都需要开一个 Hotfix 分支，完成后，向 Developer 分支和 Master 分支上合并。合并完成后，删除 Hotfix 分支。</li></ul><p>通过整个 GitFlow 协同工作流程可以看到：</p><ol><li>要长期维护 Master 和 Developer 两个分支。</li><li>这种方式还是有一定复杂度的，尤其是 Release 和 Hotfix 分支需要同时向两个分支作合并。所以，如果没有一个好的工具来支撑的话，这会因为我们可能会忘了做一些操作而导致代码不一致。</li><li>GitFlow 协同虽然工作流比较重。但是它几乎可以应对所有公司的各种开发流程，包括瀑布模型，或是快速迭代模型。</li></ol><p>之后有不需要维护多个版本，也不需要关注不同的运行环境，只需要一套代码，就可以了。GitHub Flow/Gitlab Flow 或是功能分支这种方式也更适应这种开发方式也更适应这种开发。</p>]]></content>
      
      
      <categories>
          
          <category> 管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何选择开源协议</title>
      <link href="/posts/eaf9fa7f.html"/>
      <url>/posts/eaf9fa7f.html</url>
      
        <content type="html"><![CDATA[<p>应该怎样选择这最常见的六种开源协议：GPL、BSD、MIT、Mozilla、Apache、LGPL。<br>我们先画图分析这六种许可证之间的区别。</p><p>他人修改源代码后是否可以闭源？</p><p><img src="/images/a138b03e673ba553cd0e50d371e317e5.jpg" alt="a138b03e673ba553cd0e50d371e317e5.jpeg"></p><p>Reference：<br><a href="http://www.gnu.org/licenses/license-list.html" target="_blank" rel="noopener">http://www.gnu.org/licenses/license-list.html</a><br><a href="http://pbagwl.com/post/5078147450/description-of-popular-software-licenses" target="_blank" rel="noopener">http://pbagwl.com/post/5078147450/description-of-popular-software-licenses</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 开源 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于时间与效率</title>
      <link href="/posts/6451b7b0.html"/>
      <url>/posts/6451b7b0.html</url>
      
        <content type="html"><![CDATA[<h3 id="关于时间"><a href="#关于时间" class="headerlink" title="关于时间"></a>关于时间</h3><p><strong>1.进程切换非常昂贵，避免多任务，保持单进程。</strong>（不要同时做多件事，结果可能都没做好，还拖长了工作时间。多任务状态会花费更多的时间。）</p><p><strong>2.研究表明，集中注意力、高效工作，每天最多4小时。</strong>（个人能够集中注意力的时间，是有限的。一般来说，高效工作只能持续四个小时，其余时间就都是低效工作了。）</p><p><strong>3.划分任务的优先级，不要把’急切’当作’重要’。</strong>（你的时间有限，不可能做所有事。最重要的事，应该首先做。一个有用的技巧是，将所有任务按照”重要性”和”紧急性”两个维度，分成四个象限。第一象限优先级最高，第四象限最低。）</p><p><strong>4.起床后，不要查看邮件和微信。</strong>（早晨精力最充沛，消耗在邮件和微信就太可惜了，应该用来做更重要的事。而且，邮件代表对别人优先级高，不等于对你优先级高。你的时间到底属于谁？你自己，还是某个给你写信的人）</p><p><strong>5.避免开会，因为人类已知的最浪费时间的事情，就是开会。</strong>（越大的公司，越无法避免开会。但至少不要参加与你无关的会。站着开会，也许是一个缩短会议时间的好办法。）</p><p><strong>6.早晨4点起床，到了中午，你就完成了一天的任务。</strong>（早晨4点起床开始工作，你会发现每天的时间多出了好多。有个日本人写了一本书《四点起床》，就是讲这个观点。）</p><p><strong>7.你没空时不会做的事情，有空了也不会做。</strong>（世上并没有拖延症，只是不想做而已。如果可能，应该尽早放弃你没有意愿去做的那些事。而那些没有时间也会去做的事，才是你应该全力以赴的人生方向。）</p><h3 id="关于效率"><a href="#关于效率" class="headerlink" title="关于效率"></a>关于效率</h3><p>1.效率低，往往是因为不专注，要求自己每件事都要有时间点和完成里程碑。</p><p>2.哪怕一个很大的工程，当你切成五十段之后，面临的第一个任务也无非是挖一个大坑。</p><p>3.想清楚重要性，比着急出发更重要，如果每天只做三件事，那该做哪三件事。</p><p>4.在错误的道路上跑的越快越没救，不走弯路才是效率高的体现，不是走得快。</p><p>5.一切以结果为导向，每次都激励自己赶紧忙完这一段，就可以接着忙下一段了。</p><p>Reference：<br><a href="http://www.ruanyifeng.com/blog/2011/01/never_check_email_first_thing_in_the_morning.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2011/01/never_check_email_first_thing_in_the_morning.html</a><br><a href="http://www.ruanyifeng.com/blog/2009/01/stuff_that_matters.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2009/01/stuff_that_matters.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 时间效率 </tag>
            
            <tag> 管理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>区块链技术</title>
      <link href="/posts/9ad5026b.html"/>
      <url>/posts/9ad5026b.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-技术概要"><a href="#1-技术概要" class="headerlink" title="1.技术概要"></a>1.技术概要</h3><p><strong>比特币</strong>：去中心化，数据防篡改，固定发行量。</p><p><strong>去中心化的交易</strong>：用户把交易传到网络，节点拼算力争记账权，节点计算打包全网广播，其<br>他节点验证后加入自己的区块。</p><p><strong>区块链</strong>：区块id，前区块id，数据（id由数据生成），一处改后续都改的一个连锁效应。</p><p><strong>工作量证明共识机制</strong>：修改成本高几乎不可能篡改，51%算力几乎不可能，解决分歧大多数人选择的链。（挖矿：穷举的方式查找符合的区块id）</p><h3 id="2-哈希算法"><a href="#2-哈希算法" class="headerlink" title="2.哈希算法"></a>2.哈希算法</h3><p>hash算法校验文件与数字签名，区块链使用SHA-256。</p><p><strong>比特币中的区块</strong></p><ul><li>Version: 版本号 4字</li><li>Previous Block Hash: 前块hash 32字</li><li>Merkle Root: 交易信息的hash值 32字</li><li>Timestamp: 区块生成的时间，所有节点时间的中位数 4字</li><li>Bits: hash生成难度（Difficulty Tagrget） 4字</li><li>Nonce: 随机值，用于找到满足条件的hash值 4字</li></ul><p>六个字段区块头（1M），两次hash值为id，Bits字段控制hash，你通过Nonce找到符合的has值就是挖矿。</p><p><strong>Merkle Root</strong>: 类似二叉树一样的向上两两Hash，优点：</p><ol><li>数据小尺寸化利于校验整合 </li><li>内存开销小提高校验难易度 </li><li>小数据片传输提高速度</li></ol><p>以太坊有三个Merkle Root树：做交易hash，做只能合约State同步，做交易收据</p><p><strong>比特币的交易类型</strong>：一笔交易包含大量input和output，没有余额概念可以并行多笔交易，统计UTXO交易记录查币。（整个链走一遍验证你账户上的钱是怎么来的）</p><h3 id="3-加密与挖矿"><a href="#3-加密与挖矿" class="headerlink" title="3.加密与挖矿"></a>3.加密与挖矿</h3><p><strong>密钥</strong>: 非对称加密 公钥 私钥。</p><p><strong>签名</strong>: 私钥加密Digest(信息的hash)得到签名。</p><p><strong>证书</strong>: 中间人攻击（偷换公钥），权威机构的私钥加密他的公钥和信息生成证书。你用权威机构的公钥解密证书得到得到他的公钥和签名。</p><p><strong>比特币的加密</strong>：ECDSA密钥对比技术，用户的公钥为账户<br>发起交易：A的私钥加密交易信息和地址生成签名，放出交易信息 地址  签名 公钥，等其他人验证。<br> 验证交易：A的公钥解密签名，得到hash,交易信息与自己的地址做hash,看与签名解密的hash是否一致</p><p><strong>比特币挖矿</strong>：SHA-256(SHA-256 (Block Header)) &lt; Target （确保公式成立）<br>Target决定了计算出的hash字符串前面有几个零，哈希碰撞。<br>Bits控制难度系数，每2016个区块调整一次（0越多越难，目前18个0了）全网平均10分钟一块。</p><p><strong>挖矿流程</strong>：</p><ol><li>取得网上区块信息 </li><li>获取待记账交易数据 </li><li>形成块头 </li><li>穷举Nonce(如果有18个零成功，没有则重新开始) </li><li>打包成功广播消息其他矿工验证。</li></ol><h3 id="4-去中心化与共识机制"><a href="#4-去中心化与共识机制" class="headerlink" title="4.去中心化与共识机制"></a>4.去中心化与共识机制</h3><p><strong>分布式一致性算法</strong>: 拜占庭将军问题（一致性问题的虚拟模型）:CAP, FLP, DLS</p><p><strong>CAP理论</strong>：网络阻断时，你只能选择数据的一致性或可用性，两者无法兼得。</p><p><strong>FLP</strong>：异步环境中，节点网络延迟没上限，只要一个恶意节点存在。</p><p><strong>容错上线</strong>：</p><ol><li>部分同步的网络中协议最多容忍1/3拜占庭故障 </li><li>异步网络中具体性质的协议无法容忍任何错误 </li><li>同步网络中协议可容忍100%拜占庭故障。超过1/2恶意会有限制条件。</li></ol><p><strong>工作量证明机制</strong>: </p><ol><li>提高对数据的篡改成本</li><li>提高网络中有不同声音的成本 </li><li>解决分歧（算力多的为准，去中心的一致性）。</li></ol><p>问题：1.越来越中心化记账了（算力导致） 2.越来越跑不动（验证成本导致）</p><p><strong>股权证明协议</strong>：押金交的多更有记账权，（那是不中心化更好呢？）1.可以不挖矿 2.博弈论（自己不会把自己干死）</p><p><strong>PoS机制潜在的问题</strong>：1.两个分支导致没有交易 2.导致双重交易 3.贿赂攻击 4.分叉攻击</p><p><strong>DPoS机制</strong>：例如EOS代议制选举（贿选？sbtc?）中心化，政治化 演进</p><p><strong>分布式系统CAP原则</strong>： 一致性，可用性，分区容忍性，只能三选二。问题：1.安全高性能就走中心化架构了 2.去中心安全挖矿了 3.去中心高性能不安全没人用。</p><h3 id="5-智能合约"><a href="#5-智能合约" class="headerlink" title="5.智能合约"></a>5.智能合约</h3><p>民间担保：中间人可信度<br>银行资金托管业务：例如房产交易 支付宝<br>以太坊智能合约：合约代码，链上存储 ，看懂合约，执行合约，交易生成存于链上<br>合同Bug：很难补救</p><h3 id="6-传统金融与虚拟货币"><a href="#6-传统金融与虚拟货币" class="headerlink" title="6.传统金融与虚拟货币"></a>6.传统金融与虚拟货币</h3><p>金融本质：促进交易价值提升。1.信任问题 2.资金不足问题 3.大额问题<br>金融业四个重要属性：1.效率提升 2.价值提升 3.激励机制 4.信息用评级<br>经济运行原理：交易，借贷，支出变多，一片繁荣，目光短浅，形式很好，更多借贷，买金融品，金融品涨，更多投入，巨大泡沫……<br>次贷危机<br>金融监管<br>虚拟货币：需求提高 降低成本 风控评级 高级赌场？<br>比特币问题：1.交易成本上升 2.个人无法参与 3.社区利益纷争<br>功能问题：1.交易时身份验证 2.资金归属 3.损失赔偿<br>逻辑问题：1.技术驾驭能力 2.比特币颠覆了什么 3.是否取消中间商 4.到公司参与区块链？5.投资人投资去中心化的公司<br>哲学问题：去中心化就好吗？我们不需要权威机构了吗？技术可以解决信任问题吗？建设性破坏与破坏性建设如何协调？</p>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 比特币 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript 排序算法</title>
      <link href="/posts/b1a66993.html"/>
      <url>/posts/b1a66993.html</url>
      
        <content type="html"><![CDATA[<p>这里列出了几种序算法（冒泡、选择、插入、归并、快速、希尔）。 <a href="http://jsdo.it/norahiko/oxIy/fullscreen" target="_blank" rel="noopener">排序动画</a></p><h4 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h4><p>比较任何两个相邻的项,如果第一个比第二个大,则交换它们。元素项向上移动至正确的顺序,就好像气泡升至表面一样,冒泡排序因此得名。冒泡排序的时间复杂度为O(n2)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序"></a>2.选择排序</h4><p>一种原址比较排序算法。选择排序大致的思路是找到数据结构中的最小值并将其放置在第一位,接着找到第二小的值并将其放在第二位,以此类推。选择排序的时间复杂度为O(n2)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length;</span><br><span class="line">    <span class="keyword">let</span> min, temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        min = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[min]) &#123; <span class="comment">//寻找最小的数</span></span><br><span class="line">                min = j; <span class="comment">//将最小的数索的引保存</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = arr[i];</span><br><span class="line">        arr[i] = arr[min]; <span class="comment">//交换最小数的位置</span></span><br><span class="line">        arr[min] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3.插入排序"></a>3.插入排序</h4><p>将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。插入排序的基本思想是：每步将一个待排序的纪录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> key = arr[i];</span><br><span class="line">        <span class="keyword">let</span> j = i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; key) &#123;</span><br><span class="line">            arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j+<span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-归并排序"><a href="#4-归并排序" class="headerlink" title="4.归并排序"></a>4.归并排序</h4><p>采用分治法将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。时间复杂度为O(nlogn)，空间复杂度为O(n)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">leftArr, rightArr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">while</span>(leftArr.length &gt; <span class="number">0</span> &amp;&amp; rightArr.length &gt;<span class="number">0</span> )&#123;</span><br><span class="line">        <span class="keyword">if</span> (leftArr[<span class="number">0</span>] &lt; rightArr[<span class="number">0</span>]) &#123;</span><br><span class="line">            result.push(leftArr.shift()); <span class="comment">// 把最小的最先取出，放到结果集中    </span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            result.push(rightArr.shift());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.concat(leftArr).concat(rightArr); <span class="comment">//合并</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length == <span class="number">1</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="keyword">let</span> middle = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>); <span class="comment">//取中间位置</span></span><br><span class="line">    <span class="keyword">let</span> left = arr.slice(<span class="number">0</span>,middle); <span class="comment">//拆分数组</span></span><br><span class="line">    <span class="keyword">let</span> right = arr.slice(middle);</span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right)); <span class="comment">//递归合并与排序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-快速排序"><a href="#5-快速排序" class="headerlink" title="5.快速排序"></a>5.快速排序</h4><p>随机选取一个数组中的值作为基准值，从左至右取值与基准值对比大小。比基准值小的放数组左边，大的放右边，对比完成后将基准值和第一个比基准值大的值交换位置。然后将数组以基准值的位置分为两部分，继续递归以上操作。该算法的复杂度和归并排序是相同的，但是额外空间复杂度比归并排序少，只需 O(logN)，并且相比归并排序来说，所需的常数时间也更少。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) &#123; <span class="keyword">return</span> arr; &#125;</span><br><span class="line">    <span class="keyword">let</span> left = [];</span><br><span class="line">    <span class="keyword">let</span> right = [];</span><br><span class="line">    <span class="keyword">let</span> pivotIndex = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>); <span class="comment">//基准位置</span></span><br><span class="line">    <span class="keyword">let</span> pivot = arr.splice(pivotIndex, <span class="number">1</span>)[<span class="number">0</span>]; <span class="comment">//基准数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">            left.push(arr[i]); <span class="comment">//比基准数小的放在left数组</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right.push(arr[i]); <span class="comment">//大于等于基准数的放在right数组</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> quickSort(left).concat([pivot], quickSort(right)); <span class="comment">//递归处理，连接左数组、基准数、右数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他快速排序: <a href="https://github.com/dnxbf321/sort/blob/master/quick-sort.js" target="_blank" rel="noopener">https://github.com/dnxbf321/sort/blob/master/quick-sort.js</a></p><h4 id="6-希尔排序"><a href="#6-希尔排序" class="headerlink" title="6.希尔排序"></a>6.希尔排序</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> gaps = [<span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>]; <span class="comment">//定义间隔序列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> g = <span class="number">0</span>; g &lt; gaps.length; ++g) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = gaps[g]; i &lt; arr.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">let</span> j, temp = arr[i];</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &gt;= gaps[g] &amp;&amp; arr[j - gaps[g]] &gt; temp; j -= gaps[g]) &#123;</span><br><span class="line">                arr[j] = arr[j - gaps[g]]; <span class="comment">//根据间隔序列换位</span></span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="系统自带排序"><a href="#系统自带排序" class="headerlink" title="系统自带排序"></a>系统自带排序</h4><p>对于 JavaScript 系统自带排序来说，数组长度大于 10 会使用快速排序，否则使用插入排序 <a href="https://github.com/v8/v8/blob/ad82a40509c5b5b4680d4299c8f08d6c6d31af3c/src/js/array.js#L760:7" target="_blank" rel="noopener">源码实现</a>。选择插入排序是因为虽然时间复杂度很差，但是在数据量很小的情况下和 O(N * logN)相差无几，然而插入排序需要的常数时间很小，所以相对别的排序来说更快。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript 0.1+0.2 != 0.3</title>
      <link href="/posts/2f2bb790.html"/>
      <url>/posts/2f2bb790.html</url>
      
        <content type="html"><![CDATA[<p>因为 JavaScript 采用 IEEE 754 双精度版本（64位），并且只要采用 IEEE 754 的语言都有这个问题。</p><p>我们知道，科学计数法中 30000 可以写成 3x10<sup>4</sup>，以 10 为底数 4 为指数的科学计数法。在 IEEE754 标准中它是二进制数，底数为 2。</p><p>举个例子，十进制数 150，使用双精度浮点数表示，通过短除法计算，最后一个余数为高位值，于是拿到 150 对应的二进制数位 1001011，也就等于 2^8 * 0.1001011。表示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// D 表示十进制，B 表示二进制</span><br><span class="line">150D = 2^8 * 0.1001011B // 后面省略了 46 个 0</span><br></pre></td></tr></table></figure><p>小数的表示法采用的是乘二取整，与整数不同的是，第一个计算得到的整数位为最高位，故 0.1 对应的二进制数为 0.000110011(0011)，也就等于 2^-4 * 0.1100110011(0011)。如 0.1，它的二进制表示为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// (0011) 表示循环</span><br><span class="line">0.1D = 2^-4 * 0.110011(0011)</span><br></pre></td></tr></table></figure><p>如果一个数既包含整数部分，又包含小数部分，其表示法的计算，需要分拆为整数和小数两部分，然后相加得到结果。</p><p>根据上面算出这些值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0.1D = 2^-4 * 1.1001100110011001100110011001100110011001100110011010B</span><br><span class="line">0.2D = 2^-3 * 1.1001100110011001100110011001100110011001100110011010B</span><br><span class="line">0.3D = 2^-2 * 1.0011001100110011001100110011001100110011001100110011B</span><br></pre></td></tr></table></figure></p><p>0.1 + 0.2 时，先将两者指数统一为 -3，故 0.1 小数点向左移一位，于是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   0.1100110011001100110011001100110011001100110011001101B</span><br><span class="line">+  1.1001100110011001100110011001100110011001100110011010B</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">= 10.0110011001100110011001100110011001100110011001100111B</span><br></pre></td></tr></table></figure></p><p>得到的二进制数为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10.0110011001100110011001100110011001100110011001100111B</span><br></pre></td></tr></table></figure><p>小数点往左移一位使得整数部分为 1，此时尾数部分为 53 位，进一舍零，于是得到最后的值是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2^-2 * 1.0011001100110011001100110011001100110011001100110100</span><br></pre></td></tr></table></figure><p>这个值转化成真值为：0.30000000000000004。IEEE 754 双精度,六十四位中符号位占一位，整数位占十一位，其余五十二位都为小数位。因为 0.1 和 0.2 都是无限循环的二进制了，所以在小数位末尾处需要判断是否进位（就和十进制的四舍五入一样）。</p><p>那么 0.1 + 0.2 = 0.30000000000000004。</p><p>解决办法： parseFloat((0.1 + 0.2).toFixed(10)) 或者 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON" target="_blank" rel="noopener">Number.EPSILON</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript 构造函数与原型链</title>
      <link href="/posts/1c4322fc.html"/>
      <url>/posts/1c4322fc.html</url>
      
        <content type="html"><![CDATA[<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>JavaScript 创建对象的方法：1. 使用构造函数 2. 使用字面量 3. Object.create()</p><h4 id="使用构造函数"><a href="#使用构造函数" class="headerlink" title="使用构造函数"></a>使用构造函数</h4><p>使用构造函数作为对象的模板生成实例对象，函数内用 this 关键字代表生成的对象实例。就是操作一个空对象，将其”构造”为需要的样子。</p><p><strong>new 的过程：</strong></p><ul><li>创建一个新的空对象;</li><li>新对象的 <code>__proto__</code> 指向构造函数的 <code>prototype</code>;</li><li>新对象赋值给内部的 this 并执行;</li><li>返回新对象 this;</li></ul><p>使用 new 命令，构造函数内部的 this 代表了新生成的实例对象，this.price 表示实例对象有一个 price 属性，值是 10。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行构造函数，返回一个实例对象。</span></span><br><span class="line"><span class="keyword">var</span> Apple = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.price = <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> Apple();</span><br><span class="line">v.price <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>不使用 new 命令，直接调用构造函数，构造函数就变成了普通函数，并不会生成实例对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Apple = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.price = <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> v = Apple();</span><br><span class="line">v <span class="comment">// undefined</span></span><br><span class="line">price <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">window</span>.price <span class="comment">//10</span></span><br><span class="line"><span class="comment">//上面代码中，变量v变成了undefined，price属性变成了全局变量。</span></span><br></pre></td></tr></table></figure><h4 id="使用字面量"><a href="#使用字面量" class="headerlink" title="使用字面量"></a>使用字面量</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getPrototypeOf() 返回指定对象的原型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用数组字面量创建一个数组：</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(arr) === <span class="built_in">Array</span>.prototype <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用对象字面量创建一个对象：</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">name</span>: <span class="string">'jack'</span>&#125;</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(obj) === <span class="built_in">Object</span>.prototype <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类似字面量方式</span></span><br><span class="line"><span class="keyword">var</span> o2 = <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;<span class="attr">name</span>:<span class="string">'o2'</span>&#125;);</span><br></pre></td></tr></table></figure><p>使用字面量创建对象时,实际上就调用了这些<strong>构造函数生成实例对象</strong> (如Object、Array、Function等)。</p><h4 id="使用-Object-create"><a href="#使用-Object-create" class="headerlink" title="使用 Object.create()"></a>使用 Object.create()</h4><p>create 是 Object 构造函数的一个方法,该方法接受一个对象作为参数，然后以它为原型，返回一个实例对象。该实例对象完全继承参数对象的属性和方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> A = &#123;<span class="attr">name</span>:<span class="string">'jack'</span>&#125;</span><br><span class="line"><span class="keyword">var</span> B = <span class="built_in">Object</span>.create(A)</span><br><span class="line">B.__proto__ === A <span class="comment">// true</span></span><br><span class="line">B.name <span class="comment">// jack</span></span><br></pre></td></tr></table></figure></p><p>Object.create 方法生成的新对象，动态继承了原型。在原型上添加或修改任何方法，会立刻反映在新对象之上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A.age = <span class="number">24</span></span><br><span class="line">A <span class="comment">// &#123;name: "jack", age: 24&#125;</span></span><br><span class="line">A.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">//true</span></span><br><span class="line">B <span class="comment">//&#123;&#125;</span></span><br><span class="line">B.__proto__ <span class="comment">// &#123;name: "jack", age: 24&#125;</span></span><br></pre></td></tr></table></figure><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>每个构造函数都有一个 <code>prototype</code> 属性指向一个对象，用来存放共有属性的地址，每个实例对象都有一个 <code>__proto__</code> 属性指向它的构造函数的 <code>prototype</code> 属性。</p><p>每个原型对象都有一个 <code>constructor</code> 属性，指向相关联的构造函数，所以构造函数和构造函数的 <code>prototype</code> 是可以相互指向的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.__proto__ === Function.prototype //true</span><br></pre></td></tr></table></figure></p><p>构造函数的原型对象的所有属性和方法，都能被实例对象共享，如果属性和方法定义在构造函数的 <code>prototype</code> 上，那么所有实例对象就能共享，不仅节省了内存，还体现了实例对象之间的联系。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] </span><br><span class="line">arr.__proto__ === <span class="built_in">Array</span>.prototype <span class="comment">//true</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">//true</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span> <span class="comment">//true</span></span><br><span class="line"><span class="comment">// arr ---&gt; Array.prototype ---&gt; Object.prototype ---&gt; null</span></span><br></pre></td></tr></table></figure><ul><li><code>Array.prototype</code> 继承了 <code>Object.prototype</code> 的属性和方法。arr 继承了 <code>Array.prototype</code> 的属性和方法，同时也继承了 <code>Object.prototype</code> 的属性和方法。(所有对象都有 <code>valueOf</code> 和 <code>toString</code> 方法的原因是从 <code>Object.prototype</code> 继承的)</li><li><code>Object.prototype</code> 的原型是null，没有任何属性和方法，也没有自己的原型。所以原型链的尽头就是null。</li><li>所有对象都有一个 <code>__proto__</code> 属性指向一个原型（prototype），从实例对象到原型，再到原型的原型…… 这样就形成了一个<strong>原型链</strong>（prototype chain）。</li></ul><p><strong>总结：</strong></p><ol><li>Object 是所有对象的爸爸，所有对象都可以通过 <code>__proto__</code> 找到它;</li><li>Function 是所有函数的爸爸，所有函数都可以通过 <code>__proto__</code>找到它;</li><li>Function.prototype 和 Object.prototype 是两个特殊的对象，他们由引擎来创建;</li><li>除了以上两个特殊对象，其他对象都是通过构造函数 new 出来的;</li><li>函数的 prototype 是一个对象，也就是原型;</li><li>对象的 <code>__proto__</code> 指向原型， <code>__proto__</code> 将对象和原型连接起来组成了原型链;</li><li>关于继承，实例对象可以访问这根链条上的属性和方法，其实数组都继承于 Array.prototype，函数都继承于 Function.prototype；(判断是否为直接生成的实例，用 constructor 比用 instanceof 更严谨)</li></ol><p>构造函数、原型、实例、原型链之间的关系：</p><p><img src="/images/1544807307596-1e74bf82-9587-458b-bcff-62dfd57b0c87.png" alt="1544807307596-1e74bf82-9587-458b-bcff-62dfd57b0c87.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Object 的构造函数是 Function。</span></span><br><span class="line"><span class="built_in">Object</span>.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">//true</span></span><br><span class="line"><span class="comment">//Function 的构造函数是它自己。</span></span><br><span class="line"><span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype  <span class="comment">//true</span></span><br><span class="line"><span class="comment">//Function.prototype 的构造函数是 Object。</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">//true</span></span><br><span class="line"><span class="comment">//Object.prototype 的原型是 null</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>; <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>Reference：<br><a href="https://wangdoc.com/javascript/oop/index.html" target="_blank" rel="noopener">https://wangdoc.com/javascript/oop/index.html</a><br><a href="https://github.com/KieSun/Dream/issues/2" target="_blank" rel="noopener">https://github.com/KieSun/Dream/issues/2</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript 中 apply、call、bind 区别与用法</title>
      <link href="/posts/f6074965.html"/>
      <url>/posts/f6074965.html</url>
      
        <content type="html"><![CDATA[<p>apply() 方法调用一个具有给定this值的函数，以及作为一个数组（或类似数组对象）提供的参数。<br>call() 和 apply() 方法类似，区别就是 call() 方法接受的是参数列表，而 apply() 方法接受的是一个参数数组。</p><p>常用用法：</p><ol><li><p>数组之间的追加；</p></li><li><p>获取数组中的最大值和最小值，利用他们扩充作用域拥有 Math 的 min 和 max 方法；由于没有什么对象调用这个方法，所以第一个参数可以写作 null 或者本身；</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  numbers = [<span class="number">10</span>, <span class="number">18</span> , <span class="number">12</span> , <span class="number">-15</span> ]; </span><br><span class="line"><span class="keyword">var</span>  maxInNumbers = <span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, numbers);   <span class="comment">//18</span></span><br><span class="line"><span class="keyword">var</span>  maxInNumbers = <span class="built_in">Math</span>.max.call(<span class="built_in">Math</span>,<span class="number">10</span>, <span class="number">18</span> , <span class="number">12</span> , <span class="number">-15</span>); <span class="comment">//18</span></span><br></pre></td></tr></table></figure><ol start="3"><li>验证是否是数组（需要 toString() 没被重写过）；</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">'[object Array]'</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>让类数组拥有数组的方法</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比如 arguments 对象获取文档节点，并没有数组的那些方法：</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.apply(argument); </span><br><span class="line">[].slice.apply(<span class="built_in">arguments</span>);</span><br></pre></td></tr></table></figure><p>bind() 方法创建一个新的函数，在调用时设置this关键字为提供的值。并在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项。如果多次调用bind，那么多出来的次数都是无效的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = &#123;</span><br><span class="line">    _int :<span class="number">2</span>,</span><br><span class="line">    fun :<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">'box'</span>).onclick = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>._int);</span><br><span class="line">        &#125;).bind(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 这个this是fn，所以可以正确的访问_int,使用bind,会在点击之后打印2；</span></span><br><span class="line">        <span class="comment">// 但是如果使用call或者apply，那么在刷新网页时会打印2；</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn.fun();</span><br></pre></td></tr></table></figure></p><p>对于实现以下几个函数，可以从几个方面思考:<br>1.不传入第一个参数，那么默认为 window<br>2.改变了 this 指向，让新的对象可以执行该函数。那么思路是否可以变成给新的对象添加一个函数，然后在执行完以后删除？</p><p><strong>如何实现一个 bind 函数</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> _this = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">  <span class="comment">// 返回一个函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 因为返回了一个函数，我们可以 new F()，所以需要判断</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> F) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> _this(...args, ...arguments)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _this.apply(context, args.concat(...arguments))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>如何实现一个 call 函数</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> context = context || <span class="built_in">window</span></span><br><span class="line">  <span class="comment">// 给 context 添加一个属性</span></span><br><span class="line">  <span class="comment">// getValue.call(a, 'name', '24') =&gt; a.fn = getValue</span></span><br><span class="line">  context.fn = <span class="keyword">this</span></span><br><span class="line">  <span class="comment">// 将 context 后面的参数取出来</span></span><br><span class="line">  <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">  <span class="comment">// getValue.call(a, 'name', '24') =&gt; a.fn('name', '24')</span></span><br><span class="line">  <span class="keyword">var</span> result = context.fn(...args)</span><br><span class="line">  <span class="comment">// 删除 fn</span></span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>如何实现一个 apply 函数</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> context = context || <span class="built_in">window</span></span><br><span class="line">  context.fn = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">var</span> result</span><br><span class="line">  <span class="comment">// 需要判断是否存储第二个参数</span></span><br><span class="line">  <span class="comment">// 如果存在，就将第二个参数展开</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">    result = context.fn(...arguments[<span class="number">1</span>])</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = context.fn()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>总结：<br>都是用来改变函数的 this 对象的指向的；<br>第一个参数都是 this 要指向的对象；<br>都可以利用后续参数传参；<br>apply、call 是立即调用，bind 返回对应函数稍后调用；</p><p>Reference：<br><a href="https://zhuanlan.zhihu.com/p/51259309" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/51259309</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Promise 简记</title>
      <link href="/posts/57305e6d.html"/>
      <url>/posts/57305e6d.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-promise是什么"><a href="#1-promise是什么" class="headerlink" title="1.promise是什么"></a>1.promise是什么</h3><p>promise对象拥有一个叫做状态的属性，该属性不受外界影响，修改后不能再次变化。而Promise是一个构造函数，可以生成promise对象。</p><h3 id="2-promise的构造方法"><a href="#2-promise的构造方法" class="headerlink" title="2.promise的构造方法"></a>2.promise的构造方法</h3><p>resolve，reject，race，all四个方法都会返回一个promise。</p><p><strong>resolve</strong>：resolve接受一个值或是promise对象，如果接受的是promise对象，会直接返回该promise对象，否则返回完成状态的promise对象<br><strong>reject</strong>：类似resolve，返回的是拒绝状态的promise<br><strong>all</strong>：接受一个数组，分为三种情况</p><ul><li>传入空数组，返回完成状态的promise</li><li>传入的数组中没有promise，返回异步完成的prmise</li><li>传入的数组中有promise，返回处于pending状态的promise对象，在数组中的promise都成功或者有一个失败时，变成完成状态或拒绝状态</li></ul><p><strong>race</strong>：同all有点接近，在某个promise完成后，返回该值，根据状态来决定返回的是完成状态还是拒绝状态的promise<br>如果传入的是空数组，返回的promise永远是等待</p><h3 id="3-promise对象的方法"><a href="#3-promise对象的方法" class="headerlink" title="3.promise对象的方法"></a>3.promise对象的方法</h3><p><strong>then</strong>:<br>then接受两个参数，返回一个promise。第一个参数是promise在成功的情况下的回调函数，第二个参数是失败情况下的(可选)。</p><ul><li>如果then中的回调函数返回一个值，那么then返回的Promise将会成为接受状态，并且将返回的值作为接受状态的回调函数的参数值。</li><li>如果then中的回调函数抛出一个错误，那么then返回的Promise将会成为拒绝状态，并且将抛出的错误作为拒绝状态的回调函数的参数值。</li><li>如果then中的回调函数返回一个已经是接受状态的Promise，那么then返回的Promise也会成为接受状态，并且将那个Promise的接受状态的回调函数的参数值作为该被返回的Promise的接受状态回调函数的参数值。</li><li>如果then中的回调函数返回一个已经是拒绝状态的Promise，那么then返回的Promise也会成为拒绝状态，并且将那个Promise的拒绝状态的回调函数的参数值作为该被返回的Promise的拒绝状态回调函数的参数值。</li><li>如果then中的回调函数返回一个未定状态（pending）的Promise，那么then返回Promise的状态也是未定的，并且它的终态与那个Promise的终态相同；同时，它变为终态时调用的回调函数参数与那个Promise变为终态时的回调函数的参数是相同的。</li></ul><p><strong>catch</strong>:<br>跟Promise.prototype.then(undefined, onRejected)一致</p><h3 id="4-promise的优缺点"><a href="#4-promise的优缺点" class="headerlink" title="4.promise的优缺点"></a>4.promise的优缺点</h3><p>优点:</p><ol><li>跟callback相比，避免的回调地域无限嵌套，可以使用链式写法</li><li>约束了异步处理的写法</li><li>便于捕捉错误</li></ol><p>缺点:</p><ol><li>无法取消promise</li><li>无法处理多次触发的事件</li><li>无法获取当前执行的进度信息</li></ol><p><strong>注意</strong>：一些情况下可以使用Promise.race来取消promise。比如设置异步请求在三秒不成功的话取消，可以在Promise.race的第二个参数加一个三秒的定时器。</p><p>Reference：<br><a href="http://hpoenixf.com/posts/10947/" target="_blank" rel="noopener">http://hpoenixf.com/posts/10947/</a><br><a href="https://github.com/mqyqingfeng/Blog/issues/98" target="_blank" rel="noopener">https://github.com/mqyqingfeng/Blog/issues/98</a><br><a href="http://es6.ruanyifeng.com/#docs/promise#Promise-all" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/promise#Promise-all</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何建立一只远程团队</title>
      <link href="/posts/56deb5e8.html"/>
      <url>/posts/56deb5e8.html</url>
      
        <content type="html"><![CDATA[<p><strong><em> 该笔记于201707QCon大会记录@ChenHao的演讲。</em></strong></p><p>如果创建一家相同的公司，那还不如直接加入别人好了。既然创业条路本来就不好走，那就让它变得有趣些吧。</p><h6 id="与众不同"><a href="#与众不同" class="headerlink" title="与众不同"></a>与众不同</h6><p>不定时休假工作制，想休假就休假。<br>没有审批，休假、报销、出差等自己审批自己。<br>工作设备，定期集体设备升级。<br>没有升职，每个人即是最高层也是一线员工。<br>信息完全平等，所有人都知道所用信息。<br>英文，所有 文档、代码必须英文。<br>远程工作，支持边旅游边工作，工作时间和地点不限。<br>激进和高标准，对于工作要担心的不是激进而是不激进。</p><p>远程团队需要相信工程师，自我管理，自我驱动是最好的驱动力，用人不疑，疑人不用。自由是创造力的源泉，没有束缚才能飞得更高，想象力和创造力源自无拘无束，自由是进步的象征，参照开源软件，远程有问题，那么开源软件一定有问题如果你相信开源软件，那么你其实是在相信远程工作方式。</p><h6 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h6><p>沟通变得很复杂。见不到面，讲不清楚，沟通实际比较长，每个人的到的信息不完善。<br>开发速度变慢。开发速度变慢，部分工作出现拖延，每天工作时间控制不住。<br>生活和工作混淆。在家工作导致工作和生活分不清楚，生活和工作相互打扰，相互影响。<br>因为没有办公室，团队成员亲人以为你加入了一个骗子公司。</p><h6 id="效率问题"><a href="#效率问题" class="headerlink" title="效率问题"></a>效率问题</h6><p>效率=有用功/总功。提高效率应该如何做：<br>想清楚再干，学会抓重点，崇尚简化和自动化，正确的组件抽象，提高代码重用，避免无效率的组织架构和无效率的管理，开发高质量的产品，不断提高标准，创建一个持续改善的文化。</p><h6 id="软件团队的两种管理方式"><a href="#软件团队的两种管理方式" class="headerlink" title="软件团队的两种管理方式"></a>软件团队的两种管理方式</h6><p>Widget Factory (小商品工厂模式)：</p><ul><li>一般人的本性是懒惰的，工作越少越好，可能的话会逃避工作，大部分人对集体（公司，机构，单位，组织等）的目标不关心，因此管理者需要以强迫威胁处罚，指导，金钱利益等诱因激发人们的工作原动力。</li><li>公司对实实在在的软件开发漠不关心，他们想要把理想中的软件开发运作变成他们看得见的图表。</li><li>流程很重，不是单元和人员很多。</li></ul><p>Film Crews（电影工作组）：</p><ul><li>这种公司认为人是有相当高的智力和创造力的,是可以激发自己的。</li><li>每一个个体的自己专业能力,要远远优于那种被组织协调出来的能力。人们努力工作并可以享受工作。</li><li>工作职责变得非常的垂直，你需要具有从上到下的比较宽泛的各种能力。</li><li>经历了解把一个伟大的软件组合起来的每一个碎片。他的决策是鼓舞大家，守护着方向。</li><li>团队里的每个人都很关键，因为团队相信软件的结果来自所有参与者以及他们的那种独一无二的团队工作方式。</li></ul><h6 id="分布式远程团队"><a href="#分布式远程团队" class="headerlink" title="分布式远程团队"></a>分布式远程团队</h6><p>有能力的人。多面手、一专多能的人，有想法有能力的人，能自我驱动，标准高的人。<br>小而精的团队。团队人数不能多，8-10个左右，学会抓重点，使用智力不用蛮力，用重用和自动化解决人手不够的问题。<br>相同的目标和信条。相同的使命感和目标，对产品和设计有相同的理念和信条，相同的Owership和Leadership。</p><p>远程工作协议v1.0</p><ul><li>Online: 工作的时候必须在线，如果不在线，需要说一下不在线的时长。</li><li>3PS Update: 每周工作更新。Plan,Proirity,Problem,Summary。</li><li>Ownership&amp; Leadership: 如果看到团队是项目有问题的时候，不要等，也不忍，马上说出来，并给出响应的方案，自己跳出来召集开会，及时调整。不要闷在那里，自己憋。</li><li>1-2-3 Escalation:遇到问题的时候，自己一个人处理1小时内没思路，找他人小范围讨论，如果与他人2小时内没有结果，请上升到团队范围，如果在团队范围3小时内没思路，我们就需要借助外部力量了。</li><li>Design Review:对于一些重要的问题或工作，需要先把自己的想法share出来，而不是先实现。</li><li>Milestone Commitment:最好是2周以内，1周内更好。而且要承诺到。</li><li>Initiative:每个人都必须是主动的，都必须要自己发起要做的事，或是自己要认领要做的事。</li></ul><h6 id="远程工作相关实践"><a href="#远程工作相关实践" class="headerlink" title="远程工作相关实践"></a>远程工作相关实践</h6><p>Github: git实践，Issue,Pull Request,Code Review,Wiki<br>Dame Day: 演示产品，分享知识，交流心得，接收意见，改进产品<br>Document: 只准用英文，写文档等于写代码，设计文档必须有引用，必写READM<br>Async-Pair: 异步结对编程，第一个人写完另一个人修改，互相维护，交叉开发<br>Automation: 单元测试，Sanity Test,自动化部署，DevOps,开发工具<br>Rethinking: 每季计划，项目回顾，互相挑战，自我批评，反思总结</p><p>工作计划：季度聚会和季度计划，周计划（每周没人只干一件事）<br>私聊：1v1私聊（至少每月一次），想法、痛苦、趣事、忧伤…<br>Ownership: 有一个Owner推动整体项目，自己解决问题（即使是别人）<br>个人提高: 每人每年1个月的学习充电期，相互要求为自己讲解疑惑</p><h6 id="远程工具"><a href="#远程工具" class="headerlink" title="远程工具"></a>远程工具</h6><p>开发协作 Github<br>屏幕共享 TeamViewer<br>文件分享 Dropbox<br>语音群聊 WeChat<br>日常消息 Slack<br>开发环境 AWS</p><p>IMPOSSIBLE IS NOTHING,至少我敢想，我敢干！</p>]]></content>
      
      
      <categories>
          
          <category> 管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 管理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RESTful API设计</title>
      <link href="/posts/16995e02.html"/>
      <url>/posts/16995e02.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-URL设计"><a href="#1-URL设计" class="headerlink" title="1.URL设计"></a>1.URL设计</h3><p>五种 HTTP 方法对应 CRUD 操作（GET、POST、PUT、PATH、DELETE）。<br>动词+宾语结构：GET/articles<br>动词覆盖：POST模拟（PUT、PATH、DELETE），设置X-HTTP-Method-Override: PUT。<br>操作读取集合，复数URL<br>宾语是名词<br>避免多级 URL<br>GET /articles?published=true</p><h3 id="2-状态码"><a href="#2-状态码" class="headerlink" title="2.状态码"></a>2.状态码</h3><p>五类状态码：1相关信息，2操作成功，3重定向，4客户端错误，5服务器错误</p><p>API 不需要1xx状态码。</p><p>200 OK，（GET，PATCH，PUT）<br>201 Created（生成了新的资源），POST<br>202 Accepted（服务器已经收到请求，但还未进行处理，常用异步操作）<br>204 No Content（资源已经不存在），DELETE<br>301（永久重定向） 浏览器会直接跳转，API不用考虑<br>302，307 GET（暂时重定向）浏览器会直接跳转，API不用考虑<br>303 POST/PUT/DELETE（参考另一个 URL）浏览器不会自动跳转，而会让用户自己决定下一步<br>400 Bad Request：服务器不理解客户端的请求，未做任何处理<br>401 Unauthorized：用户未提供身份验证凭据，或者没有通过身份验证。<br>403 Forbidden：用户通过了身份验证，但是不具有访问资源所需的权限。<br>404 Not Found：所请求的资源不存在，或不可用。<br>405 Method Not Allowed：用户已经通过身份验证，但是所用的 HTTP 方法不在他的权限之内。<br>410 Gone：所请求的资源已从这个地址转移，不再可用。<br>415 Unsupported Media Type：客户端要求的返回格式不支持。比如，API 只能返回 JSON 格式，但是客户端要求返回 XML 格式。<br>422 Unprocessable Entity ：客户端上传的附件无法处理，导致请求失败。<br>429 Too Many Requests：客户端的请求次数超过限额。<br>500 Internal Server Error：客户端请求有效，服务器处理时发生了意外。<br>503 Service Unavailable：服务器无法处理请求，一般用于网站维护状态。</p><h3 id="3-服务器响应"><a href="#3-服务器响应" class="headerlink" title="3.服务器响应"></a>3.服务器响应</h3><p>服务器返回JSON对象，服务器响应时，HTTP 头的Content-Type属性要设为application/json。<br>客户端请求时，HTTP 头的ACCEPT属性也要设成application/json。</p><p>发生错误时，不要返回 200 状态码，状态码反映发生的错误，具体的错误信息放在数据体里面返回</p><p>提供URL链接，例如：api.github.com 一步步查找就可以了（最好将相关链接与其他属性分开）。</p><p>Reference：<br><a href="https://blog.florimondmanca.com/restful-api-design-13-best-practices-to-make-your-users-happy" target="_blank" rel="noopener">https://blog.florimondmanca.com/restful-api-design-13-best-practices-to-make-your-users-happy</a><br><a href="https://docs.microsoft.com/en-us/azure/architecture/best-practices/api-design" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/azure/architecture/best-practices/api-design</a><br><a href="http://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CORS 跨域</title>
      <link href="/posts/7b7d69d8.html"/>
      <url>/posts/7b7d69d8.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p>跨域资源共享（CORS），允许浏览器向跨域服务器发出XMLHttpRequest或Fetch请求，避免了浏览器同源策略的限制。CORS需要浏览器和服务器同时支持。目前除了IE10以下的浏览器都已支持。<br>浏览器发现请求跨域，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，实现CORS通信的关键是服务器。<br>CORS请求分成：简单请求（simple request）和预检请求（Preflighted requests）。</p><p>满足下面条件就属于简单请求：<br>1.请求方法是这3种之一： HEAD， GET， POST<br>2.HTTP的头信息不超出以下字段：</p><ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Last-Event-ID</li><li>Content-Type（只限于3个值：application/x-www-form-urlencoded、multipart/form-data、text/plain）</li><li>详细 Fetch 规范</li></ul><p>3.请求中的任意XMLHttpRequestUpload 对象均没有注册任何事件监听器；XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。<br>4.请求中没有使用 ReadableStream 对象。</p><h3 id="2-简单请求"><a href="#2-简单请求" class="headerlink" title="2.简单请求"></a>2.简单请求</h3><p>浏览器发现简单请求，就在头信息中添加一个Origin字段（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p><p>服务器不同意：返回正常http响应，头信息没有Access-Control-Allow-Origin字段，抛出错误被onerror捕获，注意这里的状态码可能是200。</p><p>服务器同意：返回响应头信息多出几个字段：</p><ol><li>Access-Control-Allow-Origin(必选)：Origin的值或* 。</li><li>Access-Control-Allow-Credentials（可选）：布尔值，是否允许发送Cookie。</li><li>Access-Control-Expose-Headers（可选）：XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段，要拿其他字段需要在这指定。</li></ol><p>withCredentials 属性：要发送Cookie,Credentials设为true,AJAX中打开withCredentials属性,Origin不用 * 号，用具体同源信息。</p><h3 id="3-预检请求"><a href="#3-预检请求" class="headerlink" title="3.预检请求"></a>3.预检请求</h3><p>预检请求：先增加一次查询请求（查许可名单）。应对请求方法是PUT或DELETE或者Content-Type字段的类型是application/json。</p><p>预检请求方法：OPTIONS（用来询问），<br>包含Origin字段，<br>包含 Access-Control-Request-Method：用到哪些HTTP方法，<br>包含 Access-Control-Request-Headers：额外发送的头信息字段。</p><p>预检请求的响应：检查上述字段，确认是否允许，<br>浏览器否定了预检请求，抛出错误。（XXX is not allowed by XXX Origin）</p><p>其他CORS相关字段：</p><ol><li>Access-Control-Allow-Methods(必须): 所有支持的方法。</li><li>Access-Control-Allow-Headers（必须）:支持的所有头信息字段。</li><li>Access-Control-Allow-Credentials: true（与简单请求含义相同）。</li><li>Access-Control-Max-Age: 预检请求的有效期（秒），此期间，不用发出另一条预检请求。</li></ol><p>预检通过后，每次CORS与正常请求相同了。请求中Origin字段是浏览器自动添加的。<br>响应中Access-Control-Allow-Origin字段每次必须包含。</p><h3 id="4-对比JSONP"><a href="#4-对比JSONP" class="headerlink" title="4.对比JSONP"></a>4.对比JSONP</h3><p>都是跨域。JSONP只支持GET请求，支持老浏览器，可向没设置CORS的网站请求数据。CORS支持所有类型的HTTP请求。</p><p>其他：通过document.domain跨域，通过location.hash跨域，通过HTML5的postMessage方法跨域，通过window.name跨域。（中间件跨域，服务器代理跨域，Flash URLLoader跨域，动态创建script标签（简化版本的jsonp））。</p><p>注意：某些版本的Android浏览器中，因为缓存的原因，第一次进行跨域请求是正常的，但是第二次进行的时候则会失效，对于这个问题，可以通过在Header中增加Cache-Control: no-cache 阻止缓存的方式来解决这个问题。</p><p>Reference：<br><a href="http://stackoverflow.com/questions/1652850/android-webview-cookie-problem" target="_blank" rel="noopener">http://stackoverflow.com/questions/1652850/android-webview-cookie-problem</a><br><a href="https://developer.mozilla.org/en/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">https://developer.mozilla.org/en/docs/Web/HTTP/Access_control_CORS</a><br><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/04/cors.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSS 的 BFC 原理</title>
      <link href="/posts/151addc3.html"/>
      <url>/posts/151addc3.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-常见定位方案"><a href="#1-常见定位方案" class="headerlink" title="1.常见定位方案"></a>1.常见定位方案</h3><p>有三种:</p><ul><li>普通流 (normal flow): 元素按HTML文档中的位置自上而下布局。</li><li>浮动 (float)：先按照普通流，然后根据浮动方向偏移脱离普通流。</li><li>绝对定位 (absolute positioning)：整体脱离普通流，不影响兄弟元素，位置由坐标绝地。</li></ul><h3 id="2-BFC-概念"><a href="#2-BFC-概念" class="headerlink" title="2.BFC 概念"></a>2.BFC 概念</h3><p>Block Formatting context(块级格式上下文) 是 W3C 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定子元素如何定位，它和其他元素的关系和相互作用。它属于上述定位方案的普通流。BFC元素可理解为一个封闭的盒子，内部的元素无论怎么变，都不会影响到外部。</p><h3 id="3-BFC-触发"><a href="#3-BFC-触发" class="headerlink" title="3.BFC 触发"></a>3.BFC 触发</h3><p>只要符合一条件就触发：(body，float, position, display, overflow)</p><ul><li>根元素或其它包含它的元素</li><li>浮动 (元素 float 不为 none)</li><li>绝对定位元素 (元素 position 为 absolute 或 fixed)</li><li>内联块 inline-blocks (元素 display: inline-block)</li><li>表格单元格 (元素 display: table-cell，表格单元格默认属性)</li><li>表格标题 (元素 display: table-caption, 表格标题默认属性)</li><li>被声明为块级的元素 overflow 不为 visible</li><li>弹性盒 flex boxes (元素 display: flex 或 inline-flex)</li></ul><h3 id="4-BFC-作用"><a href="#4-BFC-作用" class="headerlink" title="4.BFC 作用"></a>4.BFC 作用</h3><ol><li>垂直margin合并</li></ol><p>相邻的两个盒子的外边距折叠：</p><ul><li>两正数，取大的值。</li><li>两负数，取绝对值大的值。</li><li>一正一负,两者的相加的和。</li></ul><ol start="2"><li>清除内部浮动</li></ol><p>由于容器内元素浮动，脱离了文档流，所以容器只剩下 2px 的边距高度。如果使触发容器的 BFC，那么容器将会包裹着浮动元素（给父元素设置overflow:hidden）。</p><ol start="3"><li>创建自适应两栏布局</li></ol><p>阻止元素被浮动元素覆盖（第二个元素中加入 overflow: hidden）。左边的宽度固定，右边的内容自适应宽度。</p><p>BFC内部的元素和外部的元素绝对不会互相影响，因此，当BFC外部存在浮动时，它不应该影响BFC内部Box的布局，BFC会通过变窄，而不与浮动有重叠。同样的，当BFC内部有浮动时，为了不影响外部元素的布局，BFC计算高度时会包括浮动的高度。避免margin重叠也是这样的一个道理。</p><p>Reference：<br><a href="https://www.w3.org/html/ig/zh/wiki/CSS2/visuren#block-formatting" target="_blank" rel="noopener">https://www.w3.org/html/ig/zh/wiki/CSS2/visuren#block-formatting</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Flexbox 布局</title>
      <link href="/posts/791d8db1.html"/>
      <url>/posts/791d8db1.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p>传统盒子模型布局依赖 display、position、float，对特殊布局非常不方便，如（垂直居中,等量宽高,多列同高）。Flex（Flexible Box）弹性布局，可以灵活、响应式地布局各种页面，将成为未来布局的首选方案。（浏览器兼容问题ie11以上）</p><p>demo: <a href="http://static.vgee.cn/static/index.html" target="_blank" rel="noopener">http://static.vgee.cn/static/index.html</a></p><p>设置Flex布局：display: flex; display: inline-flex;（-webkit-flex）<br>注意，设为 Flex 布局以后，子元素的float、clear、vertical-align和多栏布局的column-xxx，属性将失效。</p><h3 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2.基本概念"></a>2.基本概念</h3><ul><li>Flex 容器（flex container）</li><li>Flex 项目（flex item）</li><li>水平的主轴（main axis）</li><li>垂直的交叉轴（cross axis）</li><li>主轴的开始位置（与边框的交叉点）叫做（main start）</li><li>结束位置叫做（main end）</li><li>交叉轴的开始位置叫做（cross start）</li><li>结束位置叫做（cross end）</li><li>单个项目占据的主轴空间叫做（main size）</li><li>占据的交叉轴空间叫做（cross size）</li><li>项目默认沿主轴排列</li></ul><p><img src="/images/fe633eb0ed2e02924982b8397a14ce25.png" alt="fe633eb0ed2e02924982b8397a14ce25.png"></p><h3 id="2-容器属性"><a href="#2-容器属性" class="headerlink" title="2.容器属性"></a>2.容器属性</h3><p>6个容器属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. flex-direction (方向)：row | row-reverse | column | column-reverse;</span><br><span class="line">2. flex-wrap (换行)：nowrap | wrap | wrap-reverse;</span><br><span class="line">3. flex-flow (简写方向换行)： &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class="line">4. justify-content (主轴对齐)：flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">5. align-items (交叉轴对齐)：flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">6. align-content (多轴线对齐)：flex-start | flex-end | center | space-between | space-around | stretch;</span><br></pre></td></tr></table></figure><p>6个项目属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. order (排序)：&lt;integer&gt;; /* -1 0 1 */</span><br><span class="line">2. flex-grow (放大)：&lt;number&gt;; /* default 0 */</span><br><span class="line">3. flex-shrink (缩小)：&lt;number&gt;; /* default 1 */</span><br><span class="line">4. flex-basis (分配多余空间之前，项目占据的主轴空间)：&lt;length&gt; | auto; /* default auto */</span><br><span class="line">5. flex (简写)：none | [ &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;? || &lt;&apos;flex-basis&apos;&gt; ]</span><br><span class="line">6. align-self (单个与其他不同的对齐方式)： auto | flex-start | flex-end | center | baseline | stretch;</span><br></pre></td></tr></table></figure><h3 id="3-布局"><a href="#3-布局" class="headerlink" title="3.布局"></a>3.布局</h3><p>青蛙多点布局<br>网格布局（在容器里面平均分配空间，宽度为固定的百分比其余网格平均分配）<br>圣杯布局（上下左右分成三栏，如果中间三栏自动变垂直）<br>输入框布局（输入框前后按钮）<br>悬挂布局（主栏的左侧或右侧，需要添加一个图片栏）<br>固定底栏<br>流式布局（每行的项目数固定，会自动分行）</p><p>布局小游戏（Flexbox Froggy：<a href="https://flexboxfroggy.com）" target="_blank" rel="noopener">https://flexboxfroggy.com）</a></p><p>Reference：<br><a href="https://scotch.io/tutorials/a-visual-guide-to-css3-flexbox-properties" target="_blank" rel="noopener">https://scotch.io/tutorials/a-visual-guide-to-css3-flexbox-properties</a><br><a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/" target="_blank" rel="noopener">https://css-tricks.com/snippets/css/a-guide-to-flexbox/</a><br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript 运行机制</title>
      <link href="/posts/6fdc6fb4.html"/>
      <url>/posts/6fdc6fb4.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-单线程"><a href="#1-单线程" class="headerlink" title="1.单线程"></a>1.单线程</h3><p>避免多线程同时操作DOM，带来复杂的同步问题，同一个时间只能做一件事，提高效率。（Web Worker允许创建多个子线程但不得操作DOM,还是单线程）</p><h3 id="2-任务队列"><a href="#2-任务队列" class="headerlink" title="2.任务队列"></a>2.任务队列</h3><p>任务排队等待一个一个执行。如果遇到很慢的，如网络读取数据，挂起处于等待中的任务，先运行排在后面的任务。挂起的任务出了结果，再回头继续执行。</p><ul><li>同步任务（synchronous）：主线程上排队执行的任务。</li><li>异步任务（asynchronous）：不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</li></ul><p><strong>异步执行机制：</strong> （主线程 执行栈 任务队列）</p><ol><li>所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</li><li>主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。</li><li>一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</li><li>主线程不断重复上面的第三步。</li></ol><p>只要主线程空了，就会去读取”任务队列”，这就是JavaScript的运行机制。这个过程会不断重复。</p><h3 id="3-事件和回调函数"><a href="#3-事件和回调函数" class="headerlink" title="3.事件和回调函数"></a>3.事件和回调函数</h3><p>任务队列(事件的队列)：</p><ul><li>IO设备完成一项任务，就在任务队列添加一个事件。主线程来读取的就是这些事件。</li><li>还包括用户产生的事件click、scroll等，事件发生时就进入任务队列，等待主线程读取。</li></ul><p>回调函数（callback）：是挂起来的代码，主线程执行异步任务，就是执行对应的回调函数。</p><p>任务队列是一个先进先出的数据结构，只要执行栈一清空，任务队列上第一位的事件就自动进入主线程。（定时器功能使某些事件按时间返回主线程）</p><h3 id="4-事件循环-Event-Loop"><a href="#4-事件循环-Event-Loop" class="headerlink" title="4.事件循环(Event Loop)"></a>4.事件循环(Event Loop)</h3><p>主线程产生堆（heap）和栈（stack）,栈中调用外部API，向任务队列中加入事件（click、load、done）。栈中执行完，主线程就读取任务队列，依次执行回调函数。</p><p><img src="/images/da078fa3eadf3db4bf455904ae06f84b.png" alt="da078fa3eadf3db4bf455904ae06f84b.png"></p><p>例如Ajax。指定回调函数的部分（onload和onerror），在send()方法的前面或后面无关紧要，因为它们属于执行栈的一部分，系统总是执行完它们，才会去读取任务队列。</p><h3 id="5-定时器"><a href="#5-定时器" class="headerlink" title="5.定时器"></a>5.定时器</h3><p>定时器功能主要由setTimeout()和setInterval()这两个函数来完成。</p><p>定时器等到同步任务和任务队列现有的事件都处理完，才会得到执行。</p><p>定时器只是将事件插入了任务队列，必须等执行栈，执行完，主线程才会去执行它指定的回调函数。（当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在指定的时间执行）</p><p>如果setTimeout加入队列的阻塞时间大于两个setTimeout执行的间隔时间，那么先加入任务队列的先执行，尽管它里面设置的时间可能比另一个setTimeout的要大。</p><h3 id="6-Node-js的Event-Loop"><a href="#6-Node-js的Event-Loop" class="headerlink" title="6.Node.js的Event Loop"></a>6.Node.js的Event Loop</h3><p>Node.js也是单线程的Event Loop，但是它的运行机制不同于浏览器环境。</p><p><img src="/images/20c8ec0e32db9d302955408622f7c91e.png" alt="20c8ec0e32db9d302955408622f7c91e.png"></p><p><strong>Node.js的运行机制：</strong></p><ul><li>V8引擎解析JavaScript脚本。</li><li>解析后的代码，调用Node API。</li><li>libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。</li><li>V8引擎再将结果返回给用户。</li></ul><p>Node.js提供的任务队列方法：<br>process.nextTick方法，指定的任务总是发生在所有异步任务之前（本次触发）。<br>setImmediate方法，指定的任务总是在下一次Event Loop时执行（下次触发）。</p><p>Reference：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop</a><br><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/10/event-loop.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Web 前端性能优化</title>
      <link href="/posts/8a2429cf.html"/>
      <url>/posts/8a2429cf.html</url>
      
        <content type="html"><![CDATA[<p><strong>传说中的雅虎军规前端优化35条。</strong></p><h4 id="1-内容优化"><a href="#1-内容优化" class="headerlink" title="1.内容优化"></a>1.内容优化</h4><p><strong>1.尽量减少 HTTP 请求</strong></p><p>合并文件图片，脚本文件，样式表，（CSS Sprites（背景图绝对定位）、行内图片（Base64编码））。</p><p><strong>2.减少 DNS 查找</strong><br>在DNS查找完成之前，浏览器无法从主机名下载任何东西。减少不同的主机名就可以减少DNS查找。<br>DNS查找被缓存起来（网络服务提供商，本地网络服务器，操作系统，浏览器）逐级查找。<br>使用预加载提速：Controlling_DNS_prefetching，dns-prefetching</p><p><strong>3.尽量减少重定向</strong><br>Web 站点子目录的后面添加个 / (Slash) ，就能有效避免一次重定向，二者之间是有差异的。<br>Apache 服务器，通过配置 Alias 或mod_rewrite 或是 DirectorySlash 能解决这个问题。</p><p><strong>4.使得 Ajax 可缓存</strong><br>让响应变得可缓存，对 Ajax 来说至关重要。适用于Ajax的其它规则：Gzip组件、减少DNS查找、压缩JavaScript、避免重定向、配置ETags。</p><p><strong>5.延迟加载组件</strong><br>灵活运用异步思想，onload事件之前和之后的一个理想选择。</p><p><strong>6.预加载组件</strong><br>灵活运用异步思想，无条件预加载（尽快开始加载，获取一些额外的组件），条件预加载（根据用户操作猜测用户将要跳转到哪里并据此预加载），提前预加载（在推出新设计之前预加载）。</p><p><strong>7.减少 DOM 元素数量</strong><br>用更好的语义化标记。</p><p><strong>8.跨域分离组件</strong><br>提高页面组件并行下载能力。但不要跨太多域名，否则就会增减dns查询。</p><p><strong>9.最小化 iframe 的数量</strong><br>iframe 不利于 SEO。针对前端优化来说优点：引入缓慢的第三方内容，比如标志和广告、安全沙箱、并行下载脚本。缺点：阻塞页面加载，非语义。</p><p><strong>10.杜绝 http 404 错误</strong><br>充分测试页面链接，加上对 Web 服务器 error 日志的不断跟踪，能有效减少 404 错误。<br>链接到的外部JavaScript有错误而且结果是404,将阻塞并行下载。</p><h4 id="2-CSS优化"><a href="#2-CSS优化" class="headerlink" title="2.CSS优化"></a>2.CSS优化</h4><p><strong>11.避免 CSS 表达式</strong><br>通过其它手段也同样能实现更好一些。</p><p><strong>12.使用link 而不是 @import</strong><br>在 IE 中 @import 等于把 link 标记写在 HTML 的底部.</p><p><strong>13.避免使用Filter</strong><br>这个滤镜会阻塞渲染，卡住浏览器，还会增加内存消耗，用下划线hack：_filter来避免影响IE7及更高版本的用户。</p><p><strong>14.把 CSS 放到代码顶部</strong><br>把 CSS 放到代码页上端，HTML 页面从顶到下进行解析和渲染。</p><h4 id="3-JavaScript优化"><a href="#3-JavaScript优化" class="headerlink" title="3.JavaScript优化"></a>3.JavaScript优化</h4><p><strong>15.移除重复脚本</strong><br>重复脚本会创建不必要的HTTP请求，执行无用的JavaScript代码，而影响页面性能。</p><p><strong>16.减少 DOM 访问</strong><br>用JavaScript访问DOM元素是很慢的，所以应该：<br>缓存已访问过的元素的索引。<br>先“离线”更新节点，再把它们添到DOM树上。<br>避免用JavaScript修复布局问题。<br>参考《如何优化 JavaScript 脚本的性能》提高 Ajax 应用程序性能，避开 Web 服务漏洞。</p><p><strong>17.用智能的事件处理器</strong><br>有时候感觉页面反映不够灵敏，是因为有太多频繁执行的事件处理器被添加到了DOM树的不同元素上，这就是推荐使用事件委托的原因。如果一个div里面有10个按钮，应该只给div容器添加一个事件处理器，而不是给每个按钮都添加一个。事件能够冒泡，所以可以捕获事件并得知哪个按钮是事件源。</p><p><strong>18.脚本放到 HTML 代码页底部</strong><br>当一个脚本在下载的时候，浏览器干不了其它的事儿(串行了)。所以，把它扔到最后面去处理。对于一些功能性的脚本，可能实现起来有些两难。不过对于国内网站来说，有很多使用 Google Analytics 服务进行网站数据分析的。这这一点来说，绝对可行的建议，放到页面最底下。</p><p><strong>19.从页面中剥离 JavaScript 与 CSS</strong><br>用外部文件可以让页面更快，因为JavaScript和CSS文件会被缓存在浏览器。</p><p><strong>20.压缩 JavaScript 与 CSS</strong><br>去除不必要的字符以减少大小，从而提升加载速度。启用了gzip模块。</p><h4 id="4-图像优化"><a href="#4-图像优化" class="headerlink" title="4.图像优化"></a>4.图像优化</h4><p><strong>21.优化图片</strong> (Optimize Images)<br>尽可能的使用 PNG 格式的图片，在考虑用 Pngcrush 或类似的工具进行优化。<br>请设计的同学考虑面向 Web 的图片。</p><p><strong>22.使用 CSS Sprites 技巧对图片优化</strong><br>图片横向排列一般都比纵向排列的最终文件小。<br>图片相似颜色可以保持低色数，最理想的是256色以下PNG8格式。<br>考虑移动端，不要在Sprite图片中留下太大的空隙。虽然不会在很大程度上影响图片文件的大小，但这样做可以节省用户代理把图片解压成像素映射时消耗的内存。<br>一个大k图片就把整个网站拖得很慢。</p><p><strong>23.不要在 HTML 中使用缩放图片</strong><br>不要因为在HTML中可以设置宽高而使用本不需要的大图。</p><p><strong>24.用更小的并且可缓存的 favicon.ico</strong><br>足够小，越小越好。<br>设置合适的有效期HTTP头（以后如果想换的话就不能重命名了），把有效期设置为几个月后一般比较安全，可以通过检查当前favicon.ico的最后修改日期来确保变更能让浏览器知道。</p><h4 id="5-Cookie优化"><a href="#5-Cookie优化" class="headerlink" title="5.Cookie优化"></a>5.Cookie优化</h4><p><strong>25.缩小 Cookie</strong><br>清除不必要的cookie。<br>保证cookie尽可能小，以最小化对用户响应时间的影响。<br>注意给cookie设置合适的域级别，以免影响其它子域。<br>设置合适的有效期，更早的有效期或者none可以更快的删除cookie，提高用户响应时间。</p><p><strong>26.针对 Web 组件使用域名无关性的 Cookie</strong><br>当浏览器发送对静态资源的请求时，cookie也会一起发送，而服务器根本不需要这些cookie。造成没有意义的网络通信量，应该确保对静态组件的请求不含cookie。可以创建一个子域，把所有的静态组件都部署在那儿。<br>Yahoo! 的静态文件都在 yimg.com 上，客户端请求静态文件的时候，减少了 Cookie 的反复传输对主域名 (yahoo.com) 的影响。</p><h4 id="6-移动端优化"><a href="#6-移动端优化" class="headerlink" title="6.移动端优化"></a>6.移动端优化</h4><p><strong>27.保证所有组件都小于25K</strong><br>这个限制是因为iPhone不能缓存大于25K的组件，注意这里指的是未压缩的大小。这就是为什么缩减内容本身也很重要，因为单纯的gzip可能不够。</p><p>Updated: 根据这篇 iPhone caching 的文章，可供 Cache 的最大单个数据对象是 15K，而不是前面说的 25K。iPhone 总的 Cache Size 为 ###5M。浏览器地址栏的刷新按钮将导致无条件刷新所有组件。这些也是挺有趣的。</p><p><strong>28.把组件打包到一个复合文档里</strong><br>把各个组件打包成一个像有附件的电子邮件一样的复合文档里（多部分组成的文档），可以用一个HTTP请求获取多个组件（减少 HTTP 请求）。用这种方式的时候，要先检查用户代理是否支持（iPhone就不支持）。</p><h4 id="7-Server端优化"><a href="#7-Server端优化" class="headerlink" title="7.Server端优化"></a>7.Server端优化</h4><p><strong>29.使用Gzip组件</strong><br>从HTTP/1.1开始，web客户端就有了支持压缩的Accept-Encoding HTTP请求头。(Accept-Encoding: gzip, deflate)。<br>如果web服务器看到这个请求头，它就会用客户端列出的一种方式来压缩响应。web服务器通过Content-Encoding相应头来通知客户端。(Content-Encoding: gzip)</p><p><strong>30.避免图片src属性为空</strong><br>html与JavaScript的src为空，会使浏览器会向服务器发送另一个请求。</p><p><strong>31.设置 Etags</strong><br>实体标签（ETags），是服务器和浏览器用来决定浏览器缓存中组件与源服务器中的组件是否匹配的一种机制(实体即静态资源)。<br>Etag 对多数站点性能的影响并不是很大。除非是面向 RSS 的网站。（IE 的 ETag 注意 IIS事项）<br>很多网站在不注意的情况下都是打开 Etag 的，而没有网站关心如何用，消耗资源而不知。并不是说 Etag 不好，合理利用 Etag ，绝对能取得很好的收益。</p><p><strong>32.对 AJAX 请求使用 GET 方法</strong><br>XMLHttpRequest POST 要两步，先发送HTTP头，在发送数据，而 GET 只需要一步，发送一个TCP报文。但要注意的是在 IE 上 GET 最大能处理的 URL 长度是 2K。</p><p><strong>33.尽早清空缓冲区</strong><br>较理想的清空缓冲区的位置是HEAD后面，因为HTML的HEAD部分通常更容易生成，并且允许引入任何CSS和JavaScript文件，这样就可以让浏览器在后台还在处理的时候就开始并行获取组件。(异步的思路)</p><p><strong>34.使用 CDN</strong><br>最好先分散静态内容，而不是一开始就重新设计应用程序结构。这不仅能够大大减少响应时间，还更容易表现出CDN的功劳。一组分散在不同地理位置的web服务器，用来给用户更高效地发送内容。<br>国内 CDN 的普及还不够。不过我们有独特的电信、网通之间的问题，如果针对这个作优化，基本上也算能收到 CDN 或类似的效果吧(假装如此)。</p><p><strong>35.添加 Expires 或 Cache-Control 信息头</strong><br>对于静态组件：通过设置一个遥远的将来时间作为Expires来实现永不失效。<br>多余动态组件：用合适的Cache-ControlHTTP头来让浏览器进行条件性的请求。<br>Apache、Nginx的相应配置。</p><p><strong>最后使用工具 PageSpeed 一步一步来优化吧。</strong></p><p>Reference：<br><a href="https://developer.yahoo.com/performance/" target="_blank" rel="noopener">https://developer.yahoo.com/performance/</a><br><a href="http://ingf.github.io/web/2014/12/10/web-.html" target="_blank" rel="noopener">http://ingf.github.io/web/2014/12/10/web-.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>浏览器工作流程</title>
      <link href="/posts/6b002894.html"/>
      <url>/posts/6b002894.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-构建对象模型"><a href="#1-构建对象模型" class="headerlink" title="1.构建对象模型"></a>1.构建对象模型</h3><p>浏览器渲染页面前需要先构建对象模型，根据HTML和CSS输入构建了DOM树和CSSOM树，两树合并成渲染树，然后用于计算每个可见元素的布局，并输出给绘制流程，将像素渲染到屏幕上。</p><ul><li>字节 → 字符 → 令牌 → 节点 → 对象模型。(令牌:字符转W3C标准的标签)</li><li>HTML 标记转换成文档对象模型 (DOM)。</li><li>CSS 标记转换成 CSS 对象模型 (CSSOM)。</li><li>DOM 和 CSSOM 是独立的数据结构。（JavaScript可以通过DOM API和CSSOM API来操作两个树）</li><li>Chrome DevTools Timeline 可以捕获 DOM 和 CSSOM 的构建和处理开销。</li></ul><p><img src="/images/0c389301ba794f3ca7b491572d73971d.png" alt="0c389301ba794f3ca7b491572d73971d.png"></p><p>注：建立CSS树是需要比照着DOM树，CSS匹配DOM树从右到左解析CSS的Selector。因为这个过程有性能问题，所以很多人说，DOM树要小，CSS尽量用id和class，千万不要过渡层叠下去等。<br>Render Tree会把一些不可见的结点去除掉。</p><h3 id="2-构建渲染树、布局及绘制"><a href="#2-构建渲染树、布局及绘制" class="headerlink" title="2.构建渲染树、布局及绘制"></a>2.构建渲染树、布局及绘制</h3><ol><li>计算CSS样式</li><li>构建渲染树（Render Tree)</li><li>布局定位坐标和大小，是否换行，各种position, overflow, z-index属性等（Layout）</li><li>最后一步是绘制，最终渲染树将像素渲染到屏幕上。(Reflow，Repaint)</li></ol><p><strong>Repaint（重绘）</strong>: 屏幕的一部分要重画，如某个CSS的背景色变了，但是元素的几何尺寸没有变。</p><p><strong>Reflow（重排）</strong>: 渲染树的一部分或全部发生了变化，元件的几何尺寸变了，我们需要重新验证并计算渲染树。</p><blockquote><p>HTML使用的流式布局，重排会从<html>这个root frame开始递归往下，依次计算所有的结点几何尺寸和位置，在重排过程中，可能会增加一些frame，比如一个文本字符串必需被包装起来。</html></p></blockquote><p>注：Reflow的成本比Repaint的成本高得多。DOM树里的每个结点都会有reflow方法，一个结点的reflow很有可能导致子结点，甚至父点以及同级结点的reflow。</p><p>所以，下面这些动作有很大可能会是成本比较高的。</p><ul><li>当你增加、删除、修改DOM结点时，会导致Reflow或Repaint</li><li>当你移动DOM的位置，或是搞个动画的时候。</li><li>当你修改CSS样式的时候。</li><li>当你Resize窗口的时候（移动端没有这个问题），或是滚动的时候。</li><li>当你修改网页的默认字体时。</li></ul><p>注：display:none会触发reflow，而visibility:hidden只会触发repaint，因为没有发现位置变化。（前者完全看不见，后者会占着布局）</p><p>如果在滚屏的时候，我们的页面上的所有的像素都会跟着滚动，那么性能上没什么问题，因为我们的显卡对于这种把全屏像素往上往下移的算法是很快。但是如果你有一个fixed的背景图，或是有些Element不跟着滚动，有些Elment是动画，那么这个滚动的动作对于浏览器来说会是相当相当痛苦的一个过程。你可以看到很多这样的网页在滚动的时候性能有多差。因为滚屏也有可能会造成reflow。</p><p>基本上来说，reflow有如下的几个原因：</p><ul><li>Initial。网页初始化的时候。</li><li>Incremental。一些Javascript在操作DOM Tree时。</li><li>Resize。某些元件的尺寸变了。</li><li>StyleChange。如果CSS的属性发生变化了。</li><li>Dirty。几个Incremental的reflow发生在同一个frame的子树上。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bstyle = <span class="built_in">document</span>.body.style; <span class="comment">// cache</span></span><br><span class="line">bstyle.padding = <span class="string">"20px"</span>; <span class="comment">// reflow, repaint</span></span><br><span class="line">bstyle.border = <span class="string">"10px solid red"</span>; <span class="comment">//  再一次的 reflow 和 repaint </span></span><br><span class="line">bstyle.color = <span class="string">"blue"</span>; <span class="comment">// repaint</span></span><br><span class="line">bstyle.backgroundColor = <span class="string">"#fad"</span>; <span class="comment">// repaint</span></span><br><span class="line">bstyle.fontSize = <span class="string">"2em"</span>; <span class="comment">// reflow, repaint </span></span><br><span class="line"><span class="comment">// new DOM element - reflow, repaint</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'dude!'</span>));</span><br></pre></td></tr></table></figure><p>当然，我们的浏览器是聪明的，它不会像上面那样，你每改一次样式，它就reflow或repaint一次。一般来说，浏览器会把这样的操作积攒一批，然后做一次reflow，这又叫异步reflow或增量异步reflow。但是有些情况浏览器是不会这么做的，比如：resize窗口，改变了页面默认的字体，等。对于这些操作，浏览器会马上进行reflow。</p><p>但是有些时候，我们的脚本会阻止浏览器这么干，比如：如果我们请求下面的一些DOM值：</p><ol><li>offsetTop, offsetLeft, offsetWidth, offsetHeight</li><li>scrollTop/Left/Width/Height</li><li>clientTop/Left/Width/Height</li><li>IE中的 getComputedStyle(), 或 currentStyle</li></ol><p>因为，如果我们的程序需要这些值，那么浏览器需要返回最新的值，而这样也会做出一些样式的改变，从而造成频繁的reflow/repaint。</p><h3 id="3-优化关键渲染路径与性能"><a href="#3-优化关键渲染路径与性能" class="headerlink" title="3.优化关键渲染路径与性能"></a>3.优化关键渲染路径与性能</h3><p>减少reflow/repaint来优化性能：</p><p>1.不要一条一条地修改DOM的样式。可以预先定义好class，然后修改DOM的className。<br>2.把DOM离线后修改</p><ul><li>使用documentFragment 对象在内存里操作DOM</li><li>先把DOM给display:none(有一次reflow)，然后你想怎么改就怎么改。比如修改100次，然后再把他显示出来。</li><li>clone一个DOM结点到内存里，改完后和在线的那个的交换一下。</li></ul><p>3.不要把DOM结点的属性值放在一个循环里当成循环里的变量。会导致大量地读写这个结点的属性。<br>4.尽可能的修改层级比较低的DOM。当然，改变层级比较底的DOM有可能会造成大面积的reflow，但是也可能影响范围很小。<br>5.为动画的HTML元件使用fixed或absoult的position，那么修改他们的CSS是不会reflow的。<br>6.千万不要使用table布局。因为可能很小的一个小改动会造成整个table的重新布局。</p><p><strong>最后简述浏览器工作步骤：</strong></p><ol><li>处理 HTML 标记并构建 DOM 树。</li><li>处理 CSS 标记并构建 CSSOM 树。</li><li>将 DOM 与 CSSOM 合并成一个渲染树。</li><li>根据渲染树来布局，以计算每个节点的几何信息。</li><li>将各个节点绘制到屏幕上。</li><li>我们的演示网页看起来可能很简单，实际上却需要完成相当多的工作。如果 DOM 或 CSSOM 被修改，您只能再执行一遍以上所有步骤，以确定哪些像素需要在屏幕上进行重新渲染。</li></ol><p>Reference：<br><a href="https://developers.google.com/speed/docs/insights/rules?csw=1" target="_blank" rel="noopener">https://developers.google.com/speed/docs/insights/rules?csw=1</a><br><a href="https://developer.yahoo.com/performance/rules.html?guccounter=1" target="_blank" rel="noopener">https://developer.yahoo.com/performance/rules.html?guccounter=1</a><br><a href="http://stevesouders.com/hpws/rules.php" target="_blank" rel="noopener">http://stevesouders.com/hpws/rules.php</a><br><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=zh-cn" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=zh-cn</a><br><a href="https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/" target="_blank" rel="noopener">https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/</a><br><a href="https://coolshell.cn/articles/9666.html" target="_blank" rel="noopener">https://coolshell.cn/articles/9666.html</a><br><a href="https://juejin.im/entry/59e1d31f51882578c3411c77" target="_blank" rel="noopener">https://juejin.im/entry/59e1d31f51882578c3411c77</a><br><a href="https://www.jianshu.com/p/d616d887953a" target="_blank" rel="noopener">https://www.jianshu.com/p/d616d887953a</a><br><a href="https://zhuanlan.zhihu.com/p/33149162" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/33149162</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>浏览器缓存机制</title>
      <link href="/posts/7beb4c43.html"/>
      <url>/posts/7beb4c43.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-缓存的工作原理"><a href="#1-缓存的工作原理" class="headerlink" title="1.缓存的工作原理"></a>1.缓存的工作原理</h3><p>所有缓存都是由一套规则决定什么时候使用缓存中的副本，这些规则定义在协议中（http1.0/1.1）或由缓存管理员设置（如DBA、浏览器的用户、代理服务器管理员或者应用开发者）。</p><h3 id="2-浏览器缓存规则"><a href="#2-浏览器缓存规则" class="headerlink" title="2.浏览器缓存规则"></a>2.浏览器缓存规则</h3><p>规则定义在HTTP协议头和HTML页面的Meta标签中。用新鲜度和校验值来规定浏览器是否可以直接使用缓存，还是需要去源服务器获取更新的版本。</p><p><strong>新鲜度（过期机制）</strong>：<br>1.在有效期内的，含有完整的过期时间控制头信息（HTTP协议报头）。<br>2.浏览器已经使用过这个缓存副本，并且在一个会话中已经检查过新鲜度。</p><p><strong>校验值（验证机制）</strong>：<br>服务器返回资源的时候有时在控制头信息带上这个资源的实体标签Etag（Entity Tag），再次请求过程的校验标识。不匹配则被修改或过期了，浏览器需求重新获取资源内容。</p><h3 id="3-浏览器缓存控制"><a href="#3-浏览器缓存控制" class="headerlink" title="3.浏览器缓存控制"></a>3.浏览器缓存控制</h3><p><strong>使用HTML Meta 标签</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">META</span> <span class="attr">HTTP-EQUIV</span>=<span class="string">"Pragma"</span> <span class="attr">CONTENT</span>=<span class="string">"no-cache"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>页面不被缓存，每次都去服务器拉取。（仅部分浏览器可以支持）</p><p><strong>使用缓存有关的HTTP消息报头</strong><br>一个URI的完整HTTP协议交互过程是由HTTP请求和HTTP响应组成的。在HTTP请求和响应的消息报头中，常见的与缓存有关的消息报头有：<br><img src="/images/f13fbce9ebb19c90b60539e982a383de.png" alt="f13fbce9ebb19c90b60539e982a383de.png"></p><p><strong>Cache-Control 与 Expires</strong>: </p><ul><li>有效期，控制浏览器读缓存还是读服务器。前者配置更多，优先级更高。</li></ul><p><strong>Last-Modified/ETag 与 Cache-Control/Expires</strong>：</p><ul><li>前者是先询问服务器是否有更改，没有则返回304读本地缓存，有则返回改过的数据。</li><li>后者先读本地有效期内缓存，不发请求。优先级更高。</li><li>一般情况下同时使用，因为即使点击“刷新“忽略缓存继续请求，也会返回304以减少开销。</li></ul><p><strong>Last-Modified 与 ETag</strong>：<br>HTTP1.1中Etag（实体标识）解决几个Last-Modified比较难解决的问题：</p><ol><li>秒内的新鲜度无法标注。（Last-Modified只到秒级）</li><li>文件内容没变化Last-Modified却变了，无法使用缓存。</li><li>服务器时间不一致。</li></ol><p>Etag是资源在服务器唯一标识符，先验证ETag -&gt; 在对比Last-Modified -&gt; 是否返回304。</p><p><strong>用户操作行为与缓存</strong>：</p><ul><li><p>地址栏回车、页面链接跳转、新开窗口、前进后退，两种缓存设置均有效。</p></li><li><p>刷新：会忽略Expires/Cache-Control的设置，再次发请求，而Last-Modified/Etag还是有效的，服务器会根据情况判断返回304还是200。</p></li><li><p>强制刷新：全失效，重新从服务器拉资源。</p></li></ul><h3 id="4-哪些请求不能被缓存？"><a href="#4-哪些请求不能被缓存？" class="headerlink" title="4.哪些请求不能被缓存？"></a>4.哪些请求不能被缓存？</h3><ul><li><p>HTTP响应头中不包含Last-Modified/Etag，也不包含Cache-Control/Expires的请求无法被缓存</p></li><li><p>HTTP信息头中包含Cache-Control:no-cache，pragma:no-cache，或Cache-Control:max-age=0等告诉浏览器不用缓存的请求。</p></li><li><p>需要根据Cookie，认证信息等决定输入内容的动态请求是不能被缓存的。</p></li><li><p>POST请求无法被缓存。</p></li><li><p>经过HTTPS安全加密的请求（有人也经过测试发现，ie其实在头部加入Cache-Control：max-age信息，firefox在头部加入Cache-Control:Public之后，能够对HTTPS的资源进行缓存，参考《HTTPS的七个误解》）。</p></li></ul><h3 id="5-HTML5-本地缓存"><a href="#5-HTML5-本地缓存" class="headerlink" title="5.HTML5 本地缓存"></a>5.HTML5 本地缓存</h3><p>浏览器的Application面板，Frames（可看到HTTP文件缓存），Local Storage，Session Storage，indexDB，Web SQL，Cookie，Cache Storage，Application Cache。</p><p><strong>HTTP文件缓存</strong></p><p>基于HTTP协议的浏览器端文件级缓存机制，缓存原理就是Cache-Control和Etag那套，这里略。</p><p><img src="/images/6813214-c47a662cf6211444.png" alt="6813214-c47a662cf6211444.png"></p><p><strong>localStorage</strong><br>本地缓存方案，四个核心API：</p><ol><li>setItem(key,value); </li><li>getItem(key); </li><li>removeItem(key); </li><li>clear();</li></ol><ul><li>单域名下localStorage在不同浏览器中有长度限制且各不相同；IE8以上为5MB，Chrome或Safari约为2.6MB；</li><li>只支持简单数据类型，对象类型需JSON.stringify转换</li><li>多tab打开同域名页面时，localStorage是共享的</li></ul><p><strong>sessionStorage</strong><br>浏览器关闭会清除（使用不多）。</p><p><strong>IndexDB</strong><br>虽可保存50MB的数据在本地(但不安全)。</p><p><strong>WebSQL</strong><br>不是HTML5规范，是单独的规范，HTML5之前就存在；JS端可以操作的小型数据库，兼容性和使用场景有限。</p><p><strong>Cookie</strong></p><ul><li>单域名下有个数限制，总大小4KB；</li><li>document.cookie读取不到HttpOnly类型的cookie；</li><li>分存储型cookie（设置过期时间）和Session型cookie（不设置过期时间），后者浏览器窗口关闭而消失。</li></ul><p><strong>Cache Storage</strong></p><ul><li>在ServiceWorker中定义，用于保存ServiceWorker声明的cache对象</li><li>结合ServiceWorker，可做到Web的消息推送、离线、自动更新等。</li></ul><p><strong>Application Cache</strong><br>通过manifest配置文件，在本地有选择的存储JS,CSS,图片等。</p><p>优势：离线浏览，快读加载，本地读取，资源更新才会拉取数据，减轻服务器压力。</p><p>注意：</p><ol><li>引用manifest的HTML，及静态资源必须与manifest同源。</li><li>Application Cache已被废弃，将由ServiceWorker代替。</li></ol><p>Reference：<br><a href="http://www.alloyteam.com/2012/03/web-cache-2-browser-cache/#prettyPhoto" target="_blank" rel="noopener">http://www.alloyteam.com/2012/03/web-cache-2-browser-cache/#prettyPhoto</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Markdown 基本用法</title>
      <link href="/posts/4d4f3465.html"/>
      <url>/posts/4d4f3465.html</url>
      
        <content type="html"><![CDATA[<h3 id="Markdown优点"><a href="#Markdown优点" class="headerlink" title="Markdown优点"></a>Markdown优点</h3><p>Markdown是一种轻量级标记语言，它以纯文本形式(易读、易写、易更改)编写文档，并最终以HTML格式发布。</p><ul><li>纯文本，兼容性极强，所有文本编辑器都可打开。</li><li>标记语法可读性强。</li><li>让你专注于文字而不是排版。</li><li>格式转换方便，轻松转换为 html、电子书等。</li><li>摆脱Word。</li><li>跨平台使用。</li><li>越来越多的网站支持Markdown。</li></ul><h3 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h3><h4 id="代码与语法高亮"><a href="#代码与语法高亮" class="headerlink" title="代码与语法高亮"></a>代码与语法高亮</h4><p>代码区块的建立是在每行加上4个空格或者一个制表符（如同写代码一样）</p><pre><code>&lt;php&gt;       echo “不带行号&quot;;&lt;/php&gt;</code></pre><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;php&gt;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'带行号'</span>;</span><br><span class="line">&lt;/php&gt;</span><br></pre></td></tr></table></figure><p> 行内需要引用代码，只要用反引号引起来</p><pre><code>Use the `console.log(&apos;test&apos;)` function.</code></pre><h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><pre><code># 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题</code></pre><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- 无序列表1</span><br><span class="line">- 无序列表2</span><br><span class="line">- 无序列表3</span><br><span class="line"></span><br><span class="line">1. 有序列表1</span><br><span class="line">2. 有序列表2</span><br><span class="line">3. 有序列表3</span><br></pre></td></tr></table></figure><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><pre><code>&gt; 这个是引用</code></pre><h4 id="粗体与斜体"><a href="#粗体与斜体" class="headerlink" title="粗体与斜体"></a>粗体与斜体</h4><pre><code>**这个是粗体***这个是斜体*</code></pre><h4 id="链接与图片"><a href="#链接与图片" class="headerlink" title="链接与图片"></a>链接与图片</h4><p>插入链接</p><pre><code>[link text](http://example.com/ &quot;optional title&quot;)</code></pre><p><a href="http://example.com/" title="optional title" target="_blank" rel="noopener">link text</a></p><pre><code> [link text][id] [id]: http://example.com/  &quot;optional title here&quot;&lt;http://example.com/&gt; or &lt;address@example.com&gt;</code></pre><p>插入图片<br>形式和链接相似，只需在链接的基础上前方加一个</p><pre><code>![alt text](/images/example.png &quot;optional title&quot;)</code></pre><p><img src="/images/4766746846417a2e706e67.png" alt="alt text" title="Fork you"></p><p>图片与链接写法结合</p><pre><code>[![alt text](/images/4766746846417a2e706e67.png &quot;Fork you&quot;)](你的链接地址)</code></pre><h4 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h4><pre><code>半方大的空白&amp;ensp;或&amp;#8194;全方大的空白&amp;emsp;或&amp;#8195;不断行的空白格&amp;nbsp;或&amp;#160;</code></pre><h4 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h4><p>可以在一行中用三个以上的星号、减号、底线来建立一个分隔线</p><hr><h4 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h4><pre><code>~~Mistaken text.~~</code></pre><p><del>Mistaken text.</del></p><h4 id="反斜杠"><a href="#反斜杠" class="headerlink" title="反斜杠\"></a>反斜杠\</h4><p>相当于反转义作用。使符号成为普通符号。</p><h4 id="符号’-’"><a href="#符号’-’" class="headerlink" title="符号’`’"></a>符号’`’</h4><pre><code>`ctrl+a`</code></pre><h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ABCD | EFGH | IGKL</span><br><span class="line">-----|------|----</span><br><span class="line">a    | b    | c</span><br><span class="line">d    | e    | f</span><br><span class="line">g    | h    | i</span><br></pre></td></tr></table></figure><table><thead><tr><th>ABCD</th><th>EFGH</th><th>IGKL</th></tr></thead><tbody><tr><td>a</td><td>b</td><td>c</td></tr><tr><td>d</td><td>e</td><td>f</td></tr><tr><td>g</td><td>h</td><td>i</td></tr></tbody></table><h4 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- [x] @mentions, #refs, [links](), **formatting**, and &lt;del&gt;tags&lt;/del&gt; are supported</span><br><span class="line">- [ ] this is an incomplete item</span><br></pre></td></tr></table></figure><ul><li style="list-style: none"><input type="checkbox" checked> @mentions, #refs, <a href="">links</a>, <strong>formatting</strong>, and <del>tags</del> are supported</li><li style="list-style: none"><input type="checkbox"> this is an incomplete item</li></ul><p>Reference：<br><a href="http://younghz.github.io/Markdown/" target="_blank" rel="noopener">http://younghz.github.io/Markdown/</a><br><a href="https://coolshell.cn/articles/11928.html" target="_blank" rel="noopener">https://coolshell.cn/articles/11928.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/4a17b156.html"/>
      <url>/posts/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>hello world </p>]]></content>
      
      
      <categories>
          
          <category> 管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 写作 </tag>
            
            <tag> 管理 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>

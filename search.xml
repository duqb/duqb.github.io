<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>比特币白皮书(中英文对照版)</title>
      <link href="/2018/11/05/btc-white-book-english-and-chinese/"/>
      <url>/2018/11/05/btc-white-book-english-and-chinese/</url>
      
        <content type="html"><![CDATA[<p>详细参考：<a href="https://github.com/xiaolai/bitcoin-whitepaper-chinese-translation/blob/master/Bitcoin-Whitepaper-EN-CN.md" target="_blank" rel="noopener">比特币白皮书(中英文对照版)</a></p><p>We have proposed a system for electronic transactions without relying on trust. We started with the usual framework of coins made from digital signatures, which provides strong control of ownership, but is incomplete without a way to prevent double-spending. To solve this, we proposed a peer-to-peer network using proof-of-work to record a public history of transactions that quickly becomes computationally impractical for an attacker to change if honest nodes control a majority of CPU power. The network is robust in its unstructured simplicity. Nodes work all at once with little coordination. They do not need to be identified, since messages are not routed to any particular place and only need to be delivered on a best effort basis. Nodes can leave and rejoin the network at will, accepting the proof-of-work chain as proof of what happened while they were gone. They vote with their CPU power, expressing their acceptance of valid blocks by working on extending them and rejecting invalid blocks by refusing to work on them. Any needed rules and incentives can be enforced with this consensus mechanism.</p><p>我们提出了一个不必依赖信任的电子交易系统；起点是一个普通的使用数字签名的硬币框架开始，虽然它提供了健壮的所有权控制，却无法避免双重支付。为了解决这个问题，我们提出一个使用工作证明机制的点对点网络去记录一个公开的交易记录历史，只要诚实节点能够控制大多数 CPU 算力，那么攻击者就仅从算力方面就不可能成功篡改系统。这个网络的健壮在于它的无结构的简单。节点们可以在很少协同的情况下瞬间同时工作。它们甚至不需要被辨认，因为消息的路径并非取决于特定的终点；消息只需要被以最大努力为基本去传播即可。节点来去自由，重新加入时，只需要接受工作证明链，作为它们离线之时所发生之一切的证明。它们通过它们的 CPU 算力投票，通过不断为链添加新的有效区块、拒绝无效区块，去表示它们对有效交易的接受与否。任何必要的规则和奖励都可以通过这个共识机制来强制实施。</p>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 比特币 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React的diff算法</title>
      <link href="/2018/09/22/react-diff/"/>
      <url>/2018/09/22/react-diff/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>React 的 diff 算法作为 Virtual DOM 的加速器，其算法上的改进优化是 React 整个界面渲染的基础，以及性能提高的保障，同时也是 React 源码中最神秘、最不可思议的部分，本文从源码入手，深入剖析 React diff 的不可思议之处.</p><h3 id="2-传统-diff-算法"><a href="#2-传统-diff-算法" class="headerlink" title="2.传统 diff 算法"></a>2.传统 diff 算法</h3><p>传统 diff 算法的复杂度为 O(n^3)，显然这是无法满足性能要求的。React 通过制定大胆的策略，将 O(n^3) 复杂度的问题转换成 O(n) 复杂度的问题。</p><p>计算一棵树形结构转换成另一棵树形结构的最少操作，是一个复杂且值得研究的问题。传统 diff 算法通过循环递归对节点进行依次对比，效率低下，算法复杂度达到 O(n^3)，其中 n 是树中节点的总数。O(n^3) 到底有多可怕，这意味着如果要展示1000个节点，就要依次执行上十亿次的比较。这种指数型的性能消耗对于前端渲染场景来说代价太高了！现今的 CPU 每秒钟能执行大约30亿条指令，即便是最高效的实现，也不可能在一秒内计算出差异情况。</p><h3 id="3-详解-React-diff"><a href="#3-详解-React-diff" class="headerlink" title="3.详解 React diff"></a>3.详解 React diff</h3><h4 id="diff-策略"><a href="#diff-策略" class="headerlink" title="diff 策略"></a>diff 策略</h4><ol><li>Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。</li><li>拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。 </li><li>对于同一层级的一组子节点，它们可以通过唯一 id 进行区分。</li></ol><p>基于以上三个前提策略，React 分别对 tree diff、component diff 以及 element diff 进行算法优化，事实也证明这三个前提策略是合理且准确的，它保证了整体界面构建的性能。</p><h4 id="tree-diff"><a href="#tree-diff" class="headerlink" title="tree diff"></a>tree diff</h4><p>对两棵树进行分层比较，只会对同一层次的节点进行比较(同一个父节点下的所有子节点)。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不在进一步比较。对树进行一次遍历就完成了整个 DOM 树的比较。</p><p>当出现节点跨层级移动时，并不会出现移动操作，而是以 A 为根节点的树被整个重新创建，由于影响性能，官方不建议进行 DOM 节点跨层级的操作。</p><blockquote><p>注意：在开发组件时，保持稳定的 DOM 结构会有助于性能的提升。例如，可以通过 CSS 隐藏或显示节点，而不是真的移除或添加 DOM 节点。</p></blockquote><h4 id="component-diff"><a href="#component-diff" class="headerlink" title="component diff"></a>component diff</h4><ul><li>同一类型的组件，按原策略继续比较 virtual DOM tree。</li><li>不同类型的组件，则判断为 dirty component，替换整个组件下的所有子节点。</li><li>同一类型的组件，Virtual DOM 没有任何变化（如果知道），通过 shouldComponentUpdate() 来判断该组件是否需要进行 diff。</li></ul><p>如果结构相似但是不同类型的组件。就不会比较二者的结构，而是直接删除重建。（很少存在）</p><h4 id="element-diff"><a href="#element-diff" class="headerlink" title="element diff"></a>element diff</h4><p>当节点处于同一层级时，React diff 提供了三种节点操作，分别为：INSERT_MARKUP（插入）、MOVE_EXISTING（移动）和 REMOVE_NODE（删除）。</p><ul><li>插入：新的 component 类型不在老集合里， 即是全新的节点，对新节点执行插入操作。</li><li>移动：老集合有新 component 类型，且 element 是可更新的类型，generateComponentChildren 已调用 receiveComponent，这种情况下 prevChild=nextChild，就需要做移动操作，可以复用以前的 DOM 节点。</li><li>删除：老 component 类型，在新集合里也有，但对应的 element 不同则不能直接复用和更新，需要执行删除操作，或者老 component 不在新集合里的，也需要执行删除操作。</li></ul><p>新老集合进行 diff 差异化对比，通过 key 发现新老集合中的节点都是相同的节点，因此无需进行节点删除和创建，只需要将老集合中节点的位置进行移动，更新为新集合中节点的位置</p><blockquote><p>建议：在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作，当节点数量过大或更新操作过于频繁时，在一定程度上会影响 React 的渲染性能。</p></blockquote><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h3><ol><li>React 通过 diff 策略，将 O(n3) 复杂度的问题转换成 O(n) 复杂度的问题；</li><li>React 通过分层求异的策略，对 tree diff 进行算法优化；</li><li>React 通过相同类生成相似树形结构，不同类生成不同树形结构的策略，对 component diff 进行算法优化；</li><li>React 通过设置唯一 key的策略，对 element diff 进行算法优化；</li><li>建议，在开发组件时，保持稳定的 DOM 结构会有助于性能的提升；</li><li>建议，在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作，当节点数量过大或更新操作过于频繁时，在一定程度上会影响 React 的渲染性能。</li></ol><p>参考：<br><a href="https://zhuanlan.zhihu.com/p/20346379" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/20346379</a><br><a href="https://calendar.perfplanet.com/2013/diff/" target="_blank" rel="noopener">https://calendar.perfplanet.com/2013/diff/</a><br><a href="https://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf" target="_blank" rel="noopener">https://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf</a><br><a href="https://reactjs.org/docs/reconciliation.html" target="_blank" rel="noopener">https://reactjs.org/docs/reconciliation.html</a><br><a href="https://github.com/livoras/blog/issues/13" target="_blank" rel="noopener">https://github.com/livoras/blog/issues/13</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo中遇到的问题</title>
      <link href="/2018/09/20/hexo-problem/"/>
      <url>/2018/09/20/hexo-problem/</url>
      
        <content type="html"><![CDATA[<h4 id="1-文件无法删除"><a href="#1-文件无法删除" class="headerlink" title="1.文件无法删除"></a>1.文件无法删除</h4><p>不要直接修改文件名的大小写，否则会造成文件已经删除(public与source都没有了)，但浏览博客中依然会显示的情况。</p><p>解决方法：重建一个原文件，注意文件名大小写一定要相同，然后再删除一次就可以了。</p><p>hexo clean<br>hexo g -d</p><h4 id="2-分类数与标签数显示不正确"><a href="#2-分类数与标签数显示不正确" class="headerlink" title="2.分类数与标签数显示不正确"></a>2.分类数与标签数显示不正确</h4><p>参考:<br><a href="https://theme-next.iissnan.com/faqs.html" target="_blank" rel="noopener">https://theme-next.iissnan.com/faqs.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 写作 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React常见问题</title>
      <link href="/2018/09/19/react-problem/"/>
      <url>/2018/09/19/react-problem/</url>
      
        <content type="html"><![CDATA[<h3 id="1-React组件划分"><a href="#1-React组件划分" class="headerlink" title="1.React组件划分"></a>1.React组件划分</h3><p>按职责划分: UI组件负责UI的呈现，容器组件负责管理数据和逻辑。UI组件嵌套在容器组件中，容器组件通过React-redux提供的connect方法拿到store中的数据。<br>组件设计原则:<br>1.高内聚低耦合（组件自身不依赖于其他组件，抽象可复用组件让使用者之间没有耦合关系）<br>2.周期性迭代（先整体后部分再颗粒化，尽可能抽象）<br>数据管理原则:<br>1.能计算得到状态就不要单独存储。<br>2.组件尽量没有状态，所需数据通过props获取。<br>具体使用可以参照如下链接:<br><a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_three_react-redux.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_three_react-redux.html</a></p><h3 id="2-React组件的生命周期"><a href="#2-React组件的生命周期" class="headerlink" title="2.React组件的生命周期"></a>2.React组件的生命周期</h3><p>Render阶段（暂停），Pre-commit阶段（可读），commit阶段（可用）<br>1.创建时:<br>constructor: 组件更新到页面前先创建出来<br>getDefaultProps: 获取实例的默认属性 (old)<br>getInitialState: 获取每个实例的初始化状态（old）<br>componentWillMount: 组件即将被装载、渲染到页面上<br>render: 组件在这里生成虚拟的DOM节点<br>componentDidMount: 组件真正在被装载之后可操作了（ajax等）<br>2.更新时:<br>getDerivedStateFromProps: 用外部的属性初始化一些内部的状态（16.3引入）<br>componentWillReceiveProps: 组件将要接收到属性的时候调用 （16.3被取代）<br>shouldComponentUpdate: 组件接受到新属性或者新状态的时候（可以返回false，接收数据后不更新，阻止render调用，后面的函数不会被继续执行了，可用于性能优化）<br>componentWillUpdate: 组件即将更新不能修改属性和状态<br>render: 组件重新描绘<br>getSnapshotBeforeUpdate: 例如获取滚动条滚动高度再减去,不动的效果（16.3引入）<br>componentDidUpdate: 组件已经更新<br>3.卸载时:<br>componentWillUnmount:组件即将销毁</p><h3 id="3-React性能优化方案"><a href="#3-React性能优化方案" class="headerlink" title="3.React性能优化方案"></a>3.React性能优化方案</h3><p>1.使用production版本<br>2.使用key来帮助React识别列表中所有子组件的最小变化。<br>3.重写shouldComponentUpdate来避免不必要的dom操作。(判断是否需要调用render方法重新描绘dom)<br>参考链接：<a href="https://segmentfault.com/a/1190000006254212" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006254212</a></p><h3 id="4-理解diff算法"><a href="#4-理解diff算法" class="headerlink" title="4.理解diff算法"></a>4.理解diff算法</h3><p>把树形结构按照层级分解，只比较同级元素。<br>给列表结构的每个单元添加唯一的key属性，方便比较。<br>React只会匹配相同tag class的component（这里面的class指的是组件的名字）<br>合并操作，调用component的setState方法的时候, React将其标记为dirty.到每一个事件循环结束,React检查所有标记dirty的component重新绘制。<br>选择性子树渲染。开发人员可以重写shouldComponentUpdate提高diff的性能。<br>参考链接：<a href="https://segmentfault.com/a/1190000000606216" target="_blank" rel="noopener">https://segmentfault.com/a/1190000000606216</a></p><h3 id="5-虚拟dom如何提高性能"><a href="#5-虚拟dom如何提高性能" class="headerlink" title="5.虚拟dom如何提高性能"></a>5.虚拟dom如何提高性能</h3><p>虚拟dom相当于在js和真实dom中间加了一个缓存，利用diff算法避免了没有必要的dom操作，从而提高性能。<br>步骤：<br>1.用对象结构表示DOM树的结构,然后用这个树构建一个真正的DOM树，插到文档当中。<br>2.当状态变更时，重新构造一棵新的对象树。用新的树和旧的树进行比较，记录两棵树差异。<br>3.把记录的差异应用到最开始构建的真正的DOM树上，视图就更新了。<br>参考链接：<a href="https://www.zhihu.com/question/29504639?sort=created" target="_blank" rel="noopener">https://www.zhihu.com/question/29504639?sort=created</a></p><h3 id="6-flux工作流程"><a href="#6-flux工作流程" class="headerlink" title="6.flux工作流程"></a>6.flux工作流程</h3><p>最大特点:”单向数据流”。<br>1.用户访问View<br>2.View发出用户的Action<br>3.Dispatcher收到Action，要求Store进行相应的更新<br>4.Store更新后，发出一个”change”事件<br>5.View 收到”change”事件后，更新页面<br>参考链接：<a href="http://www.ruanyifeng.com/blog/2016/01/flux.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/01/flux.html</a></p><h3 id="7-redux中间件"><a href="#7-redux中间件" class="headerlink" title="7.redux中间件"></a>7.redux中间件</h3><p>中间件提供第三方插件的模式，自定义拦截 action -&gt; reducer 的过程。<br>变为 action -&gt; middlewares -&gt; reducer 。<br>这种机制可以让我们改变数据流，实现如异步 action ，action 过滤，日志输出，异常报告等功能。<br>常见的中间件：<br>redux-logger：提供日志输出<br>redux-thunk：处理异步操作<br>redux-promise：处理异步操作，actionCreator的返回值是promise</p><h3 id="8-redux有什么缺点"><a href="#8-redux有什么缺点" class="headerlink" title="8.redux有什么缺点"></a>8.redux有什么缺点</h3><p>1.一个组件所需要的数据，必须由父组件传过来，而不能像flux中直接从store取。<br>2.当一个组件相关数据更新时，即使父组件不需要用到这个组件，父组件还是会重新render，可能会有效率影响，或者需要写复杂的shouldComponentUpdate进行判断。</p><h3 id="9-React项目中的脚手架"><a href="#9-React项目中的脚手架" class="headerlink" title="9.React项目中的脚手架"></a>9.React项目中的脚手架</h3><p>Mern：MERN是脚手架的工具，它可以很容易地使用MongoDB, Express, React and NodeJS生成同构JS应用。它最大限度地减少安装时间，并得到您使用的成熟技术来加速开发。<br>参考链接：<a href="http://www.open-open.com/lib/view/open1455953055292.html" target="_blank" rel="noopener">http://www.open-open.com/lib/view/open1455953055292.html</a></p><h3 id="11-在React当中Element和Component的区别？"><a href="#11-在React当中Element和Component的区别？" class="headerlink" title="11.在React当中Element和Component的区别？"></a>11.在React当中Element和Component的区别？</h3><p>简单地说，一个React Element描述了你想在屏幕上看到什么。换个说法就是，一个React Element是一些UI的对象表示。一个Read component是一个函数或一个类，它可以接受输入并返回一个React Element （通常是通过JSX，它被转化成一个createElement调用）。 </p><h3 id="12-可以选择性地传递给setstate的第二个参数是什么，它的目的是什么？"><a href="#12-可以选择性地传递给setstate的第二个参数是什么，它的目的是什么？" class="headerlink" title="12.可以选择性地传递给setstate的第二个参数是什么，它的目的是什么？"></a>12.可以选择性地传递给setstate的第二个参数是什么，它的目的是什么？</h3><p>一个回调函数，当setstate结束并re-rendered该组件时将被调用。一些没有说出来的东西是 setstate是异步的，这就是为什么它需要一个第二个回调函数。通常最好使用另一个生命周期方法，而不是依赖这个回调函数，但是很高兴知道它存在。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setstate( </span><br><span class="line">    &#123; <span class="attr">username</span> : <span class="string">'tylermcginnis33'</span> &#125; ,</span><br><span class="line">    ()=&gt; <span class="built_in">console</span>.log (<span class="string">'setstate has flnlshed and the component re-rende red.'</span>)</span><br><span class="line">    )</span><br></pre></td></tr></table></figure></p><p>这段代码有什么问题？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setstate ( ( prevstate , props ）=&gt; &#123; </span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">   Streak : prevstate.Streak + props.count</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>没问题。只是这种写法很少被使用，你也可以传递一个函数给setstate ，它接收到先前的状态和道具并返回一个新的状态，它不仅没有什么问题，而且如果您根据以前的状态（ state ）设置状态，推荐使用这种写法。</p><h3 id="13-为什么要使React-children-map-props-children-gt-而不是props-children-map-gt"><a href="#13-为什么要使React-children-map-props-children-gt-而不是props-children-map-gt" class="headerlink" title="13.为什么要使React.children.map(props.children,()=&gt;)而不是props.children.map(()=&gt;)"></a>13.为什么要使React.children.map(props.children,()=&gt;)而不是props.children.map(()=&gt;)</h3><p>因为不能保证props.children将是一个数组．<br>以此代码为例,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Parent&gt;</span><br><span class="line">    &lt;h1＞Welcome.&lt;/h1&gt;</span><br><span class="line">&lt;/Parent&gt;</span><br></pre></td></tr></table></figure></p><p>在父组件内部，如果我们尝试使用props.children.map映射孩子，则会抛出错误，因为props.children是一个对象，而不是一个数组。<br>如果有多个子元素React只会使props.children成为一个数组。就像下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Parent&gt;</span><br><span class="line">    &lt;h1＞Welcome.&lt;/h1&gt;</span><br><span class="line">    &lt;h2&gt;props.children will now be an array&lt;/h2&gt;</span><br><span class="line">&lt;/Parent&gt;</span><br></pre></td></tr></table></figure></p><p>这就是为什么你喜欢React.children.map,因为它的实现考虑到props.children可能是一个数组或一个对象。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>GitFlow协同工作流</title>
      <link href="/2018/08/25/gitflow/"/>
      <url>/2018/08/25/gitflow/</url>
      
        <content type="html"><![CDATA[<p>在真实的生产过程中，中心式协同工作流与功能分支协同工作流，还不能满足工作的要求。<br>这主要因为软件生产中会有各式各样的问题，并要面对不同的环境。我们要在不停地开发新代码的同时，维护线上的代码，于是，就有了下面这些需求。</p><ol><li>希望有一个干净的分支，上面是可以发布的代码，上面的改动永远都是可以发布到生产环境中的。这个分支上不能有中间开发过程中不可以上生产线的代码提交。</li><li>希望当代码达到可以上线的状态时，也就是在 alpha/beta release 时，在测试和交付的过程中，依然可以开发下一个版本的代码。</li><li>对于已经发布的代码，也会有一些 Bug-fix 的改动，不会将正在开发的代码提交到生产线上去。</li></ol><p>面对这些需求，前面的协同方式就不行了。因为我们不仅是要在整个团队中共享代码，更要管理好代码与环境的一致性。</p><p>为了解决这些问题，GitFlow 协同工作流就出来了。</p><p>GitFlow 协同工作流是由 Vincent Driessen 于 2010 年在 A successful Git branching model 这篇文章介绍给世人的。</p><p>这个协同工作流的核心思想如下图所示。<br><img src="/images/9cf4c9bc17bf11aa07d47f61d2137fca.png" alt="9cf4c9bc17bf11aa07d47f61d2137fca.png"></p><p>整个代码库中一共有五种分支。</p><ul><li>Master 主干分支，用作发布环境，上面的每一次提交都是可以发布的。</li><li>Feature 功能分支，用于开发功能，其对应的是开发环境。</li><li>Developer 开发分支，一旦功能开发完成，就向 Developer 分支合并，合并完成后，删除功能分支。这个分支对应的是集成测试环境。</li><li>Release 当 Developer 分支测试达到可以发布状态时，开出一个 Release 分支来，然后做发布前的准备工作。这个分支对应的是预发环境。之所以需要这个 Release 分支，是我们的开发可以继续向前，不会因为要发布而被 block 住而不能提交。</li><li>一旦 Release 分支上的代码达到可以上线的状态，那么需要把 Release 分支向 Master 分支和 Developer 分支同时合并，以保证代码的一致性。然后再把 Release 分支删除掉。</li><li>Hotfix 是用于处理生产线上代码的 Bug-fix，每个线上代码的 Bug-fix 都需要开一个 Hotfix 分支，完成后，向 Developer 分支和 Master 分支上合并。合并完成后，删除 Hotfix 分支。</li></ul><p>通过整个 GitFlow 协同工作流程可以看到：</p><ol><li>要长期维护 Master 和 Developer 两个分支。</li><li>这种方式还是有一定复杂度的，尤其是 Release 和 Hotfix 分支需要同时向两个分支作合并。所以，如果没有一个好的工具来支撑的话，这会因为我们可能会忘了做一些操作而导致代码不一致。</li><li>GitFlow 协同虽然工作流比较重。但是它几乎可以应对所有公司的各种开发流程，包括瀑布模型，或是快速迭代模型。</li></ol><p>之后有不需要维护多个版本，也不需要关注不同的运行环境，只需要一套代码，就可以了。GitHub Flow/Gitlab Flow 或是功能分支这种方式也更适应这种开发方式也更适应这种开发。</p><p>参考：<br>Git协同工作流，你该怎样选</p>]]></content>
      
      
      <categories>
          
          <category> 管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何选择开源协议</title>
      <link href="/2018/08/17/how-to-select-open-agreement/"/>
      <url>/2018/08/17/how-to-select-open-agreement/</url>
      
        <content type="html"><![CDATA[<p>应该怎样选择这最常见的六种开源协议：GPL、BSD、MIT、Mozilla、Apache、LGPL。<br>我们先画图分析这六种许可证之间的区别。</p><p><img src="/images/a138b03e673ba553cd0e50d371e317e5.jpg" alt="a138b03e673ba553cd0e50d371e317e5.jpeg"></p><p>参考：<br><a href="http://www.gnu.org/licenses/license-list.html" target="_blank" rel="noopener">http://www.gnu.org/licenses/license-list.html</a><br><a href="http://pbagwl.com/post/5078147450/description-of-popular-software-licenses" target="_blank" rel="noopener">http://pbagwl.com/post/5078147450/description-of-popular-software-licenses</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 开源 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于时间与效率</title>
      <link href="/2018/07/14/time-and-efficiency/"/>
      <url>/2018/07/14/time-and-efficiency/</url>
      
        <content type="html"><![CDATA[<h5 id="关于时间："><a href="#关于时间：" class="headerlink" title="关于时间："></a>关于时间：</h5><p><strong>1.进程切换非常昂贵，避免多任务，保持单进程。</strong>（不要同时做多件事，结果可能都没做好，还拖长了工作时间。多任务状态会花费更多的时间。）</p><p><strong>2.研究表明，集中注意力、高效工作，每天最多4小时。</strong>（个人能够集中注意力的时间，是有限的。一般来说，高效工作只能持续四个小时，其余时间就都是低效工作了。）</p><p><strong>3.划分任务的优先级，不要把’急切’当作’重要’。</strong>（你的时间有限，不可能做所有事。最重要的事，应该首先做。一个有用的技巧是，将所有任务按照”重要性”和”紧急性”两个维度，分成四个象限。第一象限优先级最高，第四象限最低。）</p><p><strong>4.起床后，不要查看邮件和微信。</strong>（早晨精力最充沛，消耗在邮件和微信就太可惜了，应该用来做更重要的事。而且，邮件代表对别人优先级高，不等于对你优先级高。你的时间到底属于谁？你自己，还是某个给你写信的人）</p><p><strong>5.避免开会，因为人类已知的最浪费时间的事情，就是开会。</strong>（越大的公司，越无法避免开会。但至少不要参加与你无关的会。站着开会，也许是一个缩短会议时间的好办法。）</p><p><strong>6.早晨4点起床，到了中午，你就完成了一天的任务。</strong>（早晨4点起床开始工作，你会发现每天的时间多出了好多。有个日本人写了一本书《四点起床》，就是讲这个观点。）</p><p><strong>7.你没空时不会做的事情，有空了也不会做。</strong>（世上并没有拖延症，只是不想做而已。如果可能，应该尽早放弃你没有意愿去做的那些事。而那些没有时间也会去做的事，才是你应该全力以赴的人生方向。）</p><h5 id="关于效率："><a href="#关于效率：" class="headerlink" title="关于效率："></a>关于效率：</h5><p>1.效率低，往往是因为不专注，要求自己每件事都要有时间点和完成里程碑。</p><p>2.哪怕一个很大的工程，当你切成五十段之后，面临的第一个任务也无非是挖一个大坑。</p><p>3.想清楚重要性，比着急出发更重要，如果每天只做三件事，那该做哪三件事。</p><p>4.在错误的道路上跑的越快越没救，不走弯路才是效率高的体现，不是走得快。</p><p>5.一切以结果为导向，每次都激励自己赶紧忙完这一段，就可以接着忙下一段了。</p><p>参考：<br><a href="http://www.ruanyifeng.com/blog/2011/01/never_check_email_first_thing_in_the_morning.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2011/01/never_check_email_first_thing_in_the_morning.html</a><br><a href="http://www.ruanyifeng.com/blog/2009/01/stuff_that_matters.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2009/01/stuff_that_matters.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 管理 </tag>
            
            <tag> 时间效率 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>区块链技术</title>
      <link href="/2018/06/18/block-chain-tech/"/>
      <url>/2018/06/18/block-chain-tech/</url>
      
        <content type="html"><![CDATA[<h3 id="1-技术概要"><a href="#1-技术概要" class="headerlink" title="1.技术概要"></a>1.技术概要</h3><p><strong>比特币</strong>：去中心化，数据防篡改，固定发行量。</p><p><strong>去中心化的交易</strong>：用户把交易传到网络，节点拼算力争记账权，节点计算打包全网广播，其<br>他节点验证后加入自己的区块。</p><p><strong>区块链</strong>：区块id，前区块id，数据（id由数据生成），一处改后续都改的一个连锁效应。</p><p><strong>工作量证明共识机制</strong>：修改成本高几乎不可能篡改，51%算力几乎不可能，解决分歧大多数人选择的链。（挖矿：穷举的方式查找符合的区块id）</p><h3 id="2-哈希算法"><a href="#2-哈希算法" class="headerlink" title="2.哈希算法"></a>2.哈希算法</h3><p>hash算法校验文件与数字签名，区块链使用SHA-256。</p><p><strong>比特币中的区块</strong></p><ul><li>Version: 版本号 4字</li><li>Previous Block Hash: 前块hash 32字</li><li>Merkle Root: 交易信息的hash值 32字</li><li>Timestamp: 区块生成的时间，所有节点时间的中位数 4字</li><li>Bits: hash生成难度（Difficulty Tagrget） 4字</li><li>Nonce: 随机值，用于找到满足条件的hash值 4字</li></ul><p>六个字段区块头（1M），两次hash值为id，Bits字段控制hash，你通过Nonce找到符合的has值就是挖矿。</p><p><strong>Merkle Root</strong>: 类似二叉树一样的向上两两Hash，优点：</p><ol><li>数据小尺寸化利于校验整合 </li><li>内存开销小提高校验难易度 </li><li>小数据片传输提高速度</li></ol><p>以太坊有三个Merkle Root树：做交易hash，做只能合约State同步，做交易收据</p><p><strong>比特币的交易类型</strong>：一笔交易包含大量input和output，没有余额概念可以并行多笔交易，统计UTXO交易记录查币。（整个链走一遍验证你账户上的钱是怎么来的）</p><h3 id="3-加密与挖矿"><a href="#3-加密与挖矿" class="headerlink" title="3.加密与挖矿"></a>3.加密与挖矿</h3><p><strong>密钥</strong>: 非对称加密 公钥 私钥。</p><p><strong>签名</strong>: 私钥加密Digest(信息的hash)得到签名。</p><p><strong>证书</strong>: 中间人攻击（偷换公钥），权威机构的私钥加密他的公钥和信息生成证书。你用权威机构的公钥解密证书得到得到他的公钥和签名。</p><p><strong>比特币的加密</strong>：ECDSA密钥对比技术，用户的公钥为账户<br>发起交易：A的私钥加密交易信息和地址生成签名，放出交易信息 地址  签名 公钥，等其他人验证。<br> 验证交易：A的公钥解密签名，得到hash,交易信息与自己的地址做hash,看与签名解密的hash是否一致</p><p><strong>比特币挖矿</strong>：SHA-256(SHA-256 (Block Header)) &lt; Target （确保公式成立）<br>Target决定了计算出的hash字符串前面有几个零，哈希碰撞。<br>Bits控制难度系数，每2016个区块调整一次（0越多越难，目前18个0了）全网平均10分钟一块。</p><p><strong>挖矿流程</strong>：</p><ol><li>取得网上区块信息 </li><li>获取待记账交易数据 </li><li>形成块头 </li><li>穷举Nonce(如果有18个零成功，没有则重新开始) </li><li>打包成功广播消息其他矿工验证。</li></ol><h3 id="4-去中心化与共识机制"><a href="#4-去中心化与共识机制" class="headerlink" title="4.去中心化与共识机制"></a>4.去中心化与共识机制</h3><p><strong>分布式一致性算法</strong>: 拜占庭将军问题（一致性问题的虚拟模型）:CAP, FLP, DLS</p><p><strong>CAP理论</strong>：网络阻断时，你只能选择数据的一致性或可用性，两者无法兼得。</p><p><strong>FLP</strong>：异步环境中，节点网络延迟没上限，只要一个恶意节点存在。</p><p><strong>容错上线</strong>：</p><ol><li>部分同步的网络中协议最多容忍1/3拜占庭故障 </li><li>异步网络中具体性质的协议无法容忍任何错误 </li><li>同步网络中协议可容忍100%拜占庭故障。超过1/2恶意会有限制条件。</li></ol><p><strong>工作量证明机制</strong>: </p><ol><li>提高对数据的篡改成本</li><li>提高网络中有不同声音的成本 </li><li>解决分歧（算力多的为准，去中心的一致性）。</li></ol><p>问题：1.越来越中心化记账了（算力导致） 2.越来越跑不动（验证成本导致）</p><p><strong>股权证明协议</strong>：押金交的多更有记账权，（那是不中心化更好呢？）1.可以不挖矿 2.博弈论（自己不会把自己干死）</p><p><strong>PoS机制潜在的问题</strong>：1.两个分支导致没有交易 2.导致双重交易 3.贿赂攻击 4.分叉攻击</p><p><strong>DPoS机制</strong>：例如EOS代议制选举（贿选？sbtc?）中心化，政治化 演进</p><p><strong>分布式系统CAP原则</strong>： 一致性，可用性，分区容忍性，只能三选二。问题：1.安全高性能就走中心化架构了 2.去中心安全挖矿了 3.去中心高性能不安全没人用。</p><h3 id="5-智能合约"><a href="#5-智能合约" class="headerlink" title="5.智能合约"></a>5.智能合约</h3><p>民间担保：中间人可信度<br>银行资金托管业务：例如房产交易 支付宝<br>以太坊智能合约：合约代码，链上存储 ，看懂合约，执行合约，交易生成存于链上<br>合同Bug：很难补救</p><h3 id="6-传统金融与虚拟货币"><a href="#6-传统金融与虚拟货币" class="headerlink" title="6.传统金融与虚拟货币"></a>6.传统金融与虚拟货币</h3><p>金融本质：促进交易价值提升。1.信任问题 2.自己不足问题 3.大额问题<br>金融业四个重要属性：1.效率提升 2.价值提升 3.激励机制 4.信息用评级<br>经济运行原理：交易，借贷，支出变多，一片繁荣，目光短浅，形式很好，更多借贷，买金融品，金融品涨，更多投入，巨大泡沫……<br>次贷危机<br>金融监管<br>虚拟货币：需求提高 降低成本 风控评级 高级赌场？<br>比特币问题：1.交易成本上升 2.个人无法参与 3.社区利益纷争<br>功能问题：1.交易时身份验证 2.资金归属 3.损失赔偿<br>逻辑问题：1.技术驾驭能力 2.比特币颠覆了什么 3.是否取消中间商 4.到公司参与区块链？5.投资人投资去中心化的公司<br>哲学问题：去中心化就好吗？我们不需要权威机构了吗？技术可以解决信任问题吗？建设性破坏与破坏性建设如何协调？</p>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 比特币 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Promise简记</title>
      <link href="/2017/12/13/promise/"/>
      <url>/2017/12/13/promise/</url>
      
        <content type="html"><![CDATA[<h4 id="1-promise是什么"><a href="#1-promise是什么" class="headerlink" title="1.promise是什么"></a>1.promise是什么</h4><p>promise对象拥有一个叫做状态的属性，该属性不受外界影响，修改后不能再次变化。而Promise是一个构造函数，可以生成promise对象。</p><h4 id="2-promise的构造方法"><a href="#2-promise的构造方法" class="headerlink" title="2.promise的构造方法"></a>2.promise的构造方法</h4><p>resolve，reject，race，all四个方法都会返回一个promise。</p><p><strong>resolve</strong>：resolve接受一个值或是promise对象，如果接受的是promise对象，会直接返回该promise对象，否则返回完成状态的promise对象<br><strong>reject</strong>：类似resolve，返回的是拒绝状态的promise<br><strong>all</strong>：接受一个数组，分为三种情况</p><ul><li>传入空数组，返回完成状态的promise</li><li>传入的数组中没有promise，返回异步完成的prmise</li><li>传入的数组中有promise，返回处于pending状态的promise对象，在数组中的promise都成功或者有一个失败时，变成完成状态或拒绝状态</li></ul><p><strong>race</strong>：同all有点接近，在某个promise完成后，返回该值，根据状态来决定返回的是完成状态还是拒绝状态的promise<br>如果传入的是空数组，返回的promise永远是等待</p><h4 id="3-promise对象的方法"><a href="#3-promise对象的方法" class="headerlink" title="3.promise对象的方法"></a>3.promise对象的方法</h4><p><strong>then</strong>:<br>then接受两个参数，返回一个promise。第一个参数是promise在成功的情况下的回调函数，第二个参数是失败情况下的(可选)。</p><ul><li>如果then中的回调函数返回一个值，那么then返回的Promise将会成为接受状态，并且将返回的值作为接受状态的回调函数的参数值。</li><li>如果then中的回调函数抛出一个错误，那么then返回的Promise将会成为拒绝状态，并且将抛出的错误作为拒绝状态的回调函数的参数值。</li><li>如果then中的回调函数返回一个已经是接受状态的Promise，那么then返回的Promise也会成为接受状态，并且将那个Promise的接受状态的回调函数的参数值作为该被返回的Promise的接受状态回调函数的参数值。</li><li>如果then中的回调函数返回一个已经是拒绝状态的Promise，那么then返回的Promise也会成为拒绝状态，并且将那个Promise的拒绝状态的回调函数的参数值作为该被返回的Promise的拒绝状态回调函数的参数值。</li><li>如果then中的回调函数返回一个未定状态（pending）的Promise，那么then返回Promise的状态也是未定的，并且它的终态与那个Promise的终态相同；同时，它变为终态时调用的回调函数参数与那个Promise变为终态时的回调函数的参数是相同的。</li></ul><p><strong>catch</strong>:<br>跟Promise.prototype.then(undefined, onRejected)一致</p><h4 id="3-promise的优缺点"><a href="#3-promise的优缺点" class="headerlink" title="3.promise的优缺点"></a>3.promise的优缺点</h4><p>优点:</p><ol><li>跟callback相比，避免的回调地域无限嵌套，可以使用链式写法</li><li>约束了异步处理的写法</li><li>便于捕捉错误</li></ol><p>缺点:</p><ol><li>无法取消promise</li><li>无法处理多次触发的事件</li><li>无法获取当前执行的进度信息</li></ol><p><strong>注意</strong>：一些情况下可以使用Promise.race来取消promise。比如设置异步请求在三秒不成功的话取消，可以在Promise.race的第二个参数加一个三秒的定时器。</p><p>参考：<br><a href="http://hpoenixf.com/posts/10947/" target="_blank" rel="noopener">http://hpoenixf.com/posts/10947/</a><br><a href="https://github.com/mqyqingfeng/Blog/issues/98" target="_blank" rel="noopener">https://github.com/mqyqingfeng/Blog/issues/98</a><br><a href="http://es6.ruanyifeng.com/#docs/promise#Promise-all" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/promise#Promise-all</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何建立一只远程团队</title>
      <link href="/2017/10/22/create-a-remote-work-team/"/>
      <url>/2017/10/22/create-a-remote-work-team/</url>
      
        <content type="html"><![CDATA[<p><strong><em> 该笔记于201707QCon大会记录@ChenHao的演讲。</em></strong></p><p>如果创建一家相同的公司，那还不如直接加入别人好了。既然创业条件本来就不好走，那就让它变得有趣些吧。</p><p>与众不同</p><p>不定时休假工作制，想休假就休假。<br>没有审批，休假、报销、出差等自己审批自己。<br>工作设备，定期集体设备升级。<br>没有升职，每个人即是最高层也是一线员工。<br>信息完全平等，所有人都知道所用信息。<br>英文，所有 文档、代码必须英文。<br>远程工作，支持边旅游边工作，工作时间和地点不限。<br>激进和高标准，对于工作要担心的不是激进而是不激进。</p><p>远程团队需要相信工程师，自我管理，自我驱动是最好的驱动力，用人不疑，疑人不用。自由是创造力的源泉，没有束缚才能飞得更高，想象力和创造力源自无拘无束，自由是进步的象征，参照开源软件，远程有问题，那么开源软件一定有问题如果你相信开源软件，那么你其实是在相信远程工作方式。</p><p>相关问题</p><p>沟通变得很复杂。见不到面，讲不清楚，沟通实际比较长，每个人的到的信息不完善。<br>开发速度变慢。开发速度变慢，部分工作出现拖延，每天工作时间控制不住。<br>生活和工作混淆。在家工作导致工作和生活分不清楚，生活和工作相互打扰，相互影响。<br>因为没有办公室，团队成员亲人以为你加入了一个骗子公司。</p><p>效率问题</p><p>效率=有用功/总功。提高效率应该如何做：<br>想清楚再干，学会抓重点，崇尚简化和自动化，正确的组件抽象，提高代码重用，避免无效率的组织架构和无效率的管理，开发高质量的产品，不断提高标准，创建一个持续改善的文化。</p><p>软件团队的两种管理方式</p><p>Widget Factory (小商品工厂模式)：</p><ul><li>一般人的本性是懒惰的，工作越少越好，可能的话会逃避工作，大部分人对集体（公司，机构，单位，组织等）的目标不关心，因此管理者需要以强迫威胁处罚，指导，金钱利益等诱因激发人们的工作原动力。</li><li>公司对实实在在的软件开发漠不关心，他们想要把理想中的软件开发运作变成他们看得见的图表。</li><li>流程很重，不是单元和人员很多。</li></ul><p>Film Crews（电影工作组）：</p><ul><li>这种公司认为人是有相当高的智力和创造力的,是可以激发自己的。</li><li>每一个个体的自己专业能力,要远远优于那种被组织协调出来的能力。人们努力工作并可以享受工作。</li><li>工作职责变得非常的垂直，你需要具有从上到下的比较宽泛的各种能力。</li><li>经历了解把一个伟大的软件组合起来的每一个碎片。他的决策是鼓舞大家，守护着方向。</li><li>团队里的每个人都很关键，因为团队相信软件的结果来自所有参与者以及他们的那种独一无二的团队工作方式。</li></ul><p>分布式远程团队</p><p>有能力的人。多面手、一专多能的人，有想法有能力的人，能自我驱动，标准高的人。<br>小而精的团队。团队人数不能多，8-10个左右，学会抓重点，使用智力不用蛮力，用重用和自动化解决人手不够的问题。<br>相同的目标和信条。相同的使命感和目标，对产品和设计有相同的理念和信条，相同的Owership和Leadership。</p><p>远程工作协议v1.0</p><ul><li>Online: 工作的时候必须在线，如果不在线，需要说一下不在线的时长。</li><li>3PS Update: 每周工作更新。Plan,Proirity,Problem,Summary。</li><li>Ownership&amp; Leadership: 如果看到团队是项目有问题的时候，不要等，也不忍，马上说出来，并给出响应的方案，自己跳出来召集开会，及时调整。不要闷在那里，自己憋。</li><li>1-2-3 Escalation:遇到问题的时候，自己一个人处理1小时内没思路，找他人小范围讨论，如果与他人2小时内没有结果，请上升到团队范围，如果在团队范围3小时内没思路，我们就需要借助外部力量了。</li><li>Design Review:对于一些重要的问题或工作，需要先把自己的想法share出来，而不是先实现。</li><li>Milestone Commitment:最好是2周以内，1周内更好。而且要承诺到。</li><li>Initiative:每个人都必须是主动的，都必须要自己发起要做的事，或是自己要认领要做的事。</li></ul><p>远程工作相关实践</p><p>Github: git实践，Issue,Pull Request,Code Review,Wiki<br>Dame Day: 演示产品，分享知识，交流心得，接收意见，改进产品<br>Document: 只准用英文，写文档等于写代码，设计文档必须有引用，必写READM<br>Async-Pair: 异步结对编程，第一个人写完另一个人修改，互相维护，交叉开发<br>Automation: 单元测试，Sanity Test,自动化部署，DevOps,开发工具<br>Rethinking: 每季计划，项目回顾，互相挑战，自我批评，反思总结</p><p>工作计划：季度聚会和季度计划，周计划（每周没人只干一件事）<br>私聊：1v1私聊（至少每月一次），想法、痛苦、趣事、忧伤…<br>Ownership: 有一个Owner推动整体项目，自己解决问题（即使是别人）<br>个人提高: 每人每年1个月的学习充电期，相互要求为自己讲解疑惑</p><p>远程工具</p><p>开发写作Github<br>屏幕共享TeamViewer<br>文件分析Dropbox<br>语音群聊WeChat<br>日常消息Slack<br>开发环境AWS</p><p>IMPOSSIBLE IS NOTHING,至少我敢想，我敢干！</p>]]></content>
      
      
      <categories>
          
          <category> 管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 管理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RESTful API设计</title>
      <link href="/2017/06/18/restful-api/"/>
      <url>/2017/06/18/restful-api/</url>
      
        <content type="html"><![CDATA[<h4 id="1-URL设计"><a href="#1-URL设计" class="headerlink" title="1.URL设计"></a>1.URL设计</h4><p>五种 HTTP 方法对应 CRUD 操作（GET、POST、PUT、PATH、DELETE）。<br>动词+宾语结构：GET/articles<br>动词覆盖：POST模拟（PUT、PATH、DELETE），设置X-HTTP-Method-Override: PUT。<br>操作读取集合，复数URL<br>宾语是名词<br>避免多级 URL<br>GET /articles?published=true</p><h4 id="2-状态码"><a href="#2-状态码" class="headerlink" title="2.状态码"></a>2.状态码</h4><p>五类状态码：1相关信息，2操作成功，3重定向，4客户端错误，5服务器错误</p><p>API 不需要1xx状态码。</p><p>200 OK，（GET，PATCH，PUT）<br>201 Created（生成了新的资源），POST<br>202 Accepted（服务器已经收到请求，但还未进行处理，常用异步操作）<br>204 No Content（资源已经不存在），DELETE<br>301（永久重定向） 浏览器会直接跳转，API不用考虑<br>302，307 GET（暂时重定向）浏览器会直接跳转，API不用考虑<br>303 POST/PUT/DELETE（参考另一个 URL）浏览器不会自动跳转，而会让用户自己决定下一步<br>400 Bad Request：服务器不理解客户端的请求，未做任何处理<br>401 Unauthorized：用户未提供身份验证凭据，或者没有通过身份验证。<br>403 Forbidden：用户通过了身份验证，但是不具有访问资源所需的权限。<br>404 Not Found：所请求的资源不存在，或不可用。<br>405 Method Not Allowed：用户已经通过身份验证，但是所用的 HTTP 方法不在他的权限之内。<br>410 Gone：所请求的资源已从这个地址转移，不再可用。<br>415 Unsupported Media Type：客户端要求的返回格式不支持。比如，API 只能返回 JSON 格式，但是客户端要求返回 XML 格式。<br>422 Unprocessable Entity ：客户端上传的附件无法处理，导致请求失败。<br>429 Too Many Requests：客户端的请求次数超过限额。<br>500 Internal Server Error：客户端请求有效，服务器处理时发生了意外。<br>503 Service Unavailable：服务器无法处理请求，一般用于网站维护状态。</p><h4 id="3-服务器响应"><a href="#3-服务器响应" class="headerlink" title="3.服务器响应"></a>3.服务器响应</h4><p>服务器返回JSON对象，服务器响应时，HTTP 头的Content-Type属性要设为application/json。<br>客户端请求时，HTTP 头的ACCEPT属性也要设成application/json。</p><p>发生错误时，不要返回 200 状态码，状态码反映发生的错误，具体的错误信息放在数据体里面返回</p><p>提供URL链接，例如：api.github.com 一步步查找就可以了（最好将相关链接与其他属性分开）。</p><p>参考：<br><a href="https://blog.florimondmanca.com/restful-api-design-13-best-practices-to-make-your-users-happy" target="_blank" rel="noopener">https://blog.florimondmanca.com/restful-api-design-13-best-practices-to-make-your-users-happy</a><br><a href="https://docs.microsoft.com/en-us/azure/architecture/best-practices/api-design" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/azure/architecture/best-practices/api-design</a><br><a href="http://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CORS跨域</title>
      <link href="/2017/06/15/cors-http-request/"/>
      <url>/2017/06/15/cors-http-request/</url>
      
        <content type="html"><![CDATA[<h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>跨域资源共享（CORS），允许浏览器向跨域服务器发出XMLHttpRequest或Fetch请求，避免了浏览器同源策略的限制。CORS需要浏览器和服务器同时支持。目前除了IE10以下的浏览器都已支持。<br>浏览器发现请求跨域，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，实现CORS通信的关键是服务器。<br>CORS请求分成：简单请求（simple request）和预检请求（Preflighted requests）。</p><p>满足下面条件就属于简单请求：<br>1.请求方法是这3种之一： HEAD， GET， POST<br>2.HTTP的头信息不超出以下字段：</p><ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Last-Event-ID</li><li>Content-Type（只限于3个值：application/x-www-form-urlencoded、multipart/form-data、text/plain）</li><li>详细 Fetch 规范</li></ul><p>3.请求中的任意XMLHttpRequestUpload 对象均没有注册任何事件监听器；XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。<br>4.请求中没有使用 ReadableStream 对象。</p><h4 id="2-简单请求"><a href="#2-简单请求" class="headerlink" title="2.简单请求"></a>2.简单请求</h4><p>浏览器发现简单请求，就在头信息中添加一个Origin字段（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p><p>服务器不同意：返回正常http响应，头信息没有Access-Control-Allow-Origin字段，抛出错误被onerror捕获，注意这里的状态码可能是200。</p><p>服务器同意：返回响应头信息多出几个字段：</p><ol><li>Access-Control-Allow-Origin(必选)：Origin的值或* 。</li><li>Access-Control-Allow-Credentials（可选）：布尔值，是否允许发送Cookie。</li><li>Access-Control-Expose-Headers（可选）：XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段，要拿其他字段需要在这指定。</li></ol><p>withCredentials 属性：要发送Cookie,Credentials设为true,AJAX中打开withCredentials属性,Origin不用 * 号，用具体同源信息。</p><h4 id="3-预检请求"><a href="#3-预检请求" class="headerlink" title="3.预检请求"></a>3.预检请求</h4><p>预检请求：先增加一次查询请求（查许可名单）。应对请求方法是PUT或DELETE或者Content-Type字段的类型是application/json。</p><p>预检请求方法：OPTIONS（用来询问），<br>包含Origin字段，<br>包含 Access-Control-Request-Method：用到哪些HTTP方法，<br>包含 Access-Control-Request-Headers：额外发送的头信息字段。</p><p>预检请求的响应：检查上述字段，确认是否允许，<br>浏览器否定了预检请求，抛出错误。（XXX is not allowed by XXX Origin）</p><p>其他CORS相关字段：</p><ol><li>Access-Control-Allow-Methods(必须): 所有支持的方法。</li><li>Access-Control-Allow-Headers（必须）:支持的所有头信息字段。</li><li>Access-Control-Allow-Credentials: true（与简单请求含义相同）。</li><li>Access-Control-Max-Age: 预检请求的有效期（秒），此期间，不用发出另一条预检请求。</li></ol><p>预检通过后，每次CORS与正常请求相同了。请求中Origin字段是浏览器自动添加的。<br>响应中Access-Control-Allow-Origin字段每次必须包含。</p><h4 id="4-对比JSONP"><a href="#4-对比JSONP" class="headerlink" title="4.对比JSONP"></a>4.对比JSONP</h4><p>都是跨域。JSONP只支持GET请求，支持老浏览器，可向没设置CORS的网站请求数据。CORS支持所有类型的HTTP请求。</p><p>其他：通过document.domain跨域，通过location.hash跨域，通过HTML5的postMessage方法跨域，通过window.name跨域。（中间件跨域，服务器代理跨域，Flash URLLoader跨域，动态创建script标签（简化版本的jsonp））。</p><p>注意：某些版本的Android浏览器中，因为缓存的原因，第一次进行跨域请求是正常的，但是第二次进行的时候则会失效，对于这个问题，可以通过在Header中增加Cache-Control: no-cache 阻止缓存的方式来解决这个问题。</p><p>参考：<br><a href="http://stackoverflow.com/questions/1652850/android-webview-cookie-problem" target="_blank" rel="noopener">http://stackoverflow.com/questions/1652850/android-webview-cookie-problem</a><br><a href="https://developer.mozilla.org/en/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">https://developer.mozilla.org/en/docs/Web/HTTP/Access_control_CORS</a><br><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/04/cors.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>BFC原理</title>
      <link href="/2017/03/23/bfc-principle/"/>
      <url>/2017/03/23/bfc-principle/</url>
      
        <content type="html"><![CDATA[<h4 id="1-常见定位方案"><a href="#1-常见定位方案" class="headerlink" title="1.常见定位方案"></a>1.常见定位方案</h4><p>有三种:</p><ul><li>普通流 (normal flow): 元素按HTML文档中的位置自上而下布局。</li><li>浮动 (float)：先按照普通流，然后根据浮动方向偏移脱离普通流。</li><li>绝对定位 (absolute positioning)：整体脱离普通流，不影响兄弟元素，位置由坐标绝地。</li></ul><h4 id="2-BFC-概念"><a href="#2-BFC-概念" class="headerlink" title="2.BFC 概念"></a>2.BFC 概念</h4><p>Block Formatting context(块级格式上下文) 是 W3C 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定子元素如何定位，它和其他元素的关系和相互作用。它属于上述定位方案的普通流。BFC元素可理解为一个封闭的盒子，内部的元素无论怎么变，都不会影响到外部。</p><h4 id="3-BFC-触发"><a href="#3-BFC-触发" class="headerlink" title="3.BFC 触发"></a>3.BFC 触发</h4><p>只要符合一条件就触发：(body，float, position, display, overflow)</p><ul><li>根元素或其它包含它的元素</li><li>浮动 (元素 float 不为 none)</li><li>绝对定位元素 (元素 position 为 absolute 或 fixed)</li><li>内联块 inline-blocks (元素 display: inline-block)</li><li>表格单元格 (元素 display: table-cell，表格单元格默认属性)</li><li>表格标题 (元素 display: table-caption, 表格标题默认属性)</li><li>被声明为块级的元素 overflow 不为 visible</li><li>弹性盒 flex boxes (元素 display: flex 或 inline-flex)</li></ul><h4 id="4-BFC-作用"><a href="#4-BFC-作用" class="headerlink" title="4.BFC 作用"></a>4.BFC 作用</h4><ol><li>垂直margin合并</li></ol><p>相邻的两个盒子的外边距折叠：</p><ul><li>两正数，取大的值。</li><li>两负数，取绝对值大的值。</li><li>一正一负,两者的相加的和。</li></ul><ol start="2"><li>清除内部浮动</li></ol><p>由于容器内元素浮动，脱离了文档流，所以容器只剩下 2px 的边距高度。如果使触发容器的 BFC，那么容器将会包裹着浮动元素（给父元素设置overflow:hidden）。</p><ol start="3"><li>创建自适应两栏布局</li></ol><p>阻止元素被浮动元素覆盖（第二个元素中加入 overflow: hidden）。左边的宽度固定，右边的内容自适应宽度。</p><p>BFC内部的元素和外部的元素绝对不会互相影响，因此，当BFC外部存在浮动时，它不应该影响BFC内部Box的布局，BFC会通过变窄，而不与浮动有重叠。同样的，当BFC内部有浮动时，为了不影响外部元素的布局，BFC计算高度时会包括浮动的高度。避免margin重叠也是这样的一个道理。</p><p>参考：<br><a href="https://www.w3.org/html/ig/zh/wiki/CSS2/visuren#block-formatting" target="_blank" rel="noopener">https://www.w3.org/html/ig/zh/wiki/CSS2/visuren#block-formatting</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Flexbox布局</title>
      <link href="/2017/03/22/flexbox/"/>
      <url>/2017/03/22/flexbox/</url>
      
        <content type="html"><![CDATA[<h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>传统盒子模型布局依赖 display、position、float，对特殊布局非常不方便，如（垂直居中,等量宽高,多列同高）。Flex（Flexible Box）弹性布局，可以灵活、响应式地布局各种页面，将成为未来布局的首选方案。（浏览器兼容问题ie11以上）</p><p>demo: <a href="http://static.vgee.cn/static/index.html" target="_blank" rel="noopener">http://static.vgee.cn/static/index.html</a></p><p>设置Flex布局：display: flex; display: inline-flex;（-webkit-flex）<br>注意，设为 Flex 布局以后，子元素的float、clear、vertical-align和多栏布局的column-xxx，属性将失效。</p><h4 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2.基本概念"></a>2.基本概念</h4><ul><li>Flex 容器（flex container）</li><li>Flex 项目（flex item）</li><li>水平的主轴（main axis）</li><li>垂直的交叉轴（cross axis）</li><li>主轴的开始位置（与边框的交叉点）叫做（main start）</li><li>结束位置叫做（main end）</li><li>交叉轴的开始位置叫做（cross start）</li><li>结束位置叫做（cross end）</li><li>单个项目占据的主轴空间叫做（main size）</li><li>占据的交叉轴空间叫做（cross size）</li><li>项目默认沿主轴排列</li></ul><p><img src="/images/fe633eb0ed2e02924982b8397a14ce25.png" alt="fe633eb0ed2e02924982b8397a14ce25.png"></p><h4 id="2-容器属性"><a href="#2-容器属性" class="headerlink" title="2.容器属性"></a>2.容器属性</h4><p>6个容器属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. flex-direction (方向)：row | row-reverse | column | column-reverse;</span><br><span class="line">2. flex-wrap (换行)：nowrap | wrap | wrap-reverse;</span><br><span class="line">3. flex-flow (简写方向换行)： &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class="line">4. justify-content (主轴对齐)：flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">5. align-items (交叉轴对齐)：flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">6. align-content (多轴线对齐)：flex-start | flex-end | center | space-between | space-around | stretch;</span><br></pre></td></tr></table></figure><p>6个项目属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. order (排序)：&lt;integer&gt;; /* -1 0 1 */</span><br><span class="line">2. flex-grow (放大)：&lt;number&gt;; /* default 0 */</span><br><span class="line">3. flex-shrink (缩小)：&lt;number&gt;; /* default 1 */</span><br><span class="line">4. flex-basis (分配多余空间之前，项目占据的主轴空间)：&lt;length&gt; | auto; /* default auto */</span><br><span class="line">5. flex (简写)：none | [ &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;? || &lt;&apos;flex-basis&apos;&gt; ]</span><br><span class="line">6. align-self (单个与其他不同的对齐方式)： auto | flex-start | flex-end | center | baseline | stretch;</span><br></pre></td></tr></table></figure><h4 id="3-布局"><a href="#3-布局" class="headerlink" title="3.布局"></a>3.布局</h4><p>青蛙多点布局<br>网格布局（在容器里面平均分配空间，宽度为固定的百分比其余网格平均分配）<br>圣杯布局（上下左右分成三栏，如果中间三栏自动变垂直）<br>输入框布局（输入框前后按钮）<br>悬挂布局（主栏的左侧或右侧，需要添加一个图片栏）<br>固定底栏<br>流式布局（每行的项目数固定，会自动分行）</p><p>布局小游戏Flexbox Froggy：<a href="https://flexboxfroggy.com" target="_blank" rel="noopener">https://flexboxfroggy.com</a>  </p><p>参考：<br><a href="https://scotch.io/tutorials/a-visual-guide-to-css3-flexbox-properties" target="_blank" rel="noopener">https://scotch.io/tutorials/a-visual-guide-to-css3-flexbox-properties</a><br><a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/" target="_blank" rel="noopener">https://css-tricks.com/snippets/css/a-guide-to-flexbox/</a><br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript运行机制</title>
      <link href="/2017/02/22/javascript-principle/"/>
      <url>/2017/02/22/javascript-principle/</url>
      
        <content type="html"><![CDATA[<h4 id="1-单线程"><a href="#1-单线程" class="headerlink" title="1.单线程"></a>1.单线程</h4><p>避免多线程同时操作DOM，带来复杂的同步问题，同一个时间只能做一件事，提高效率。（Web Worker允许创建多个子线程但不得操作DOM,还是单线程）</p><h4 id="2-任务队列"><a href="#2-任务队列" class="headerlink" title="2.任务队列"></a>2.任务队列</h4><p>任务排队等待一个一个执行。如果遇到很慢的，如网络读取数据，挂起处于等待中的任务，先运行排在后面的任务。挂起的任务出了结果，再回头继续执行。</p><ul><li>同步任务（synchronous）：主线程上排队执行的任务。</li><li>异步任务（asynchronous）：不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</li></ul><p><strong>异步执行机制：</strong> （主线程 执行栈 任务队列）</p><ol><li>所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</li><li>主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。</li><li>一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</li><li>主线程不断重复上面的第三步。</li></ol><p>只要主线程空了，就会去读取”任务队列”，这就是JavaScript的运行机制。这个过程会不断重复。</p><h4 id="3-事件和回调函数"><a href="#3-事件和回调函数" class="headerlink" title="3.事件和回调函数"></a>3.事件和回调函数</h4><p>任务队列(事件的队列)：</p><ul><li>IO设备完成一项任务，就在任务队列添加一个事件。主线程来读取的就是这些事件。</li><li>还包括用户产生的事件click、scroll等，事件发生时就进入任务队列，等待主线程读取。</li></ul><p>回调函数（callback）：是挂起来的代码，主线程执行异步任务，就是执行对应的回调函数。</p><p>任务队列是一个先进先出的数据结构，只要执行栈一清空，任务队列上第一位的事件就自动进入主线程。（定时器功能使某些事件按时间返回主线程）</p><h4 id="4-事件循环-Event-Loop"><a href="#4-事件循环-Event-Loop" class="headerlink" title="4.事件循环(Event Loop)"></a>4.事件循环(Event Loop)</h4><p>主线程产生堆（heap）和栈（stack）,栈中调用外部API，向任务队列中加入事件（click、load、done）。栈中执行完，主线程就读取任务队列，依次执行回调函数。</p><p><img src="/images/da078fa3eadf3db4bf455904ae06f84b.png" alt="da078fa3eadf3db4bf455904ae06f84b.png"></p><p>例如Ajax。指定回调函数的部分（onload和onerror），在send()方法的前面或后面无关紧要，因为它们属于执行栈的一部分，系统总是执行完它们，才会去读取任务队列。</p><h4 id="5-定时器"><a href="#5-定时器" class="headerlink" title="5.定时器"></a>5.定时器</h4><p>定时器功能主要由setTimeout()和setInterval()这两个函数来完成。</p><p>定时器等到同步任务和任务队列现有的事件都处理完，才会得到执行。</p><p>定时器只是将事件插入了任务队列，必须等执行栈，执行完，主线程才会去执行它指定的回调函数。（当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在指定的时间执行）</p><p>如果setTimeout加入队列的阻塞时间大于两个setTimeout执行的间隔时间，那么先加入任务队列的先执行，尽管它里面设置的时间可能比另一个setTimeout的要大。</p><h4 id="6-Node-js的Event-Loop"><a href="#6-Node-js的Event-Loop" class="headerlink" title="6.Node.js的Event Loop"></a>6.Node.js的Event Loop</h4><p>Node.js也是单线程的Event Loop，但是它的运行机制不同于浏览器环境。</p><p><img src="/images/20c8ec0e32db9d302955408622f7c91e.png" alt="20c8ec0e32db9d302955408622f7c91e.png"></p><p><strong>Node.js的运行机制：</strong></p><ul><li>V8引擎解析JavaScript脚本。</li><li>解析后的代码，调用Node API。</li><li>libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。</li><li>V8引擎再将结果返回给用户。</li></ul><p>Node.js提供的任务队列方法：<br>process.nextTick方法，指定的任务总是发生在所有异步任务之前（本次触发）。<br>setImmediate方法，指定的任务总是在下一次Event Loop时执行（下次触发）。</p><p>参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop</a><br><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/10/event-loop.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Web前端性能优化</title>
      <link href="/2017/01/04/web-frontend-optimize/"/>
      <url>/2017/01/04/web-frontend-optimize/</url>
      
        <content type="html"><![CDATA[<p><strong>传说中的雅虎军规前端优化35条。</strong></p><h4 id="1-内容优化"><a href="#1-内容优化" class="headerlink" title="1.内容优化"></a>1.内容优化</h4><p><strong>1.尽量减少 HTTP 请求</strong></p><p>合并文件图片，脚本文件，样式表，（CSS Sprites（背景图绝对定位）、行内图片（Base64编码））。</p><p><strong>2.减少 DNS 查找</strong><br>在DNS查找完成之前，浏览器无法从主机名下载任何东西。减少不同的主机名就可以减少DNS查找。<br>DNS查找被缓存起来（网络服务提供商，本地网络服务器，操作系统，浏览器）逐级查找。<br>使用预加载提速：Controlling_DNS_prefetching，dns-prefetching</p><p><strong>3.尽量减少重定向</strong><br>Web 站点子目录的后面添加个 / (Slash) ，就能有效避免一次重定向，二者之间是有差异的。<br>Apache 服务器，通过配置 Alias 或mod_rewrite 或是 DirectorySlash 能解决这个问题。</p><p><strong>4.使得 Ajax 可缓存</strong><br>让响应变得可缓存，对 Ajax 来说至关重要。适用于Ajax的其它规则：Gzip组件、减少DNS查找、压缩JavaScript、避免重定向、配置ETags。</p><p><strong>5.延迟加载组件</strong><br>灵活运用异步思想，onload事件之前和之后的一个理想选择。</p><p><strong>6.预加载组件</strong><br>灵活运用异步思想，无条件预加载（尽快开始加载，获取一些额外的组件），条件预加载（根据用户操作猜测用户将要跳转到哪里并据此预加载），提前预加载（在推出新设计之前预加载）。</p><p><strong>7.减少 DOM 元素数量</strong><br>用更好的语义化标记。</p><p><strong>8.跨域分离组件</strong><br>提高页面组件并行下载能力。但不要跨太多域名，否则就会增减dns查询。</p><p><strong>9.最小化 iframe 的数量</strong><br>iframe 不利于 SEO。针对前端优化来说优点：引入缓慢的第三方内容，比如标志和广告、安全沙箱、并行下载脚本。缺点：阻塞页面加载，非语义。</p><p><strong>10.杜绝 http 404 错误</strong><br>充分测试页面链接，加上对 Web 服务器 error 日志的不断跟踪，能有效减少 404 错误。<br>链接到的外部JavaScript有错误而且结果是404,将阻塞并行下载。</p><h4 id="2-CSS优化"><a href="#2-CSS优化" class="headerlink" title="2.CSS优化"></a>2.CSS优化</h4><p><strong>11.避免 CSS 表达式</strong><br>通过其它手段也同样能实现更好一些。</p><p><strong>12.使用link 而不是 @import</strong><br>在 IE 中 @import 等于把 link 标记写在 HTML 的底部.</p><p><strong>13.避免使用Filter</strong><br>这个滤镜会阻塞渲染，卡住浏览器，还会增加内存消耗，用下划线hack：_filter来避免影响IE7及更高版本的用户。</p><p><strong>14.把 CSS 放到代码顶部</strong><br>把 CSS 放到代码页上端，HTML 页面从顶到下进行解析和渲染。</p><h4 id="3-JavaScript优化"><a href="#3-JavaScript优化" class="headerlink" title="3.JavaScript优化"></a>3.JavaScript优化</h4><p><strong>15.移除重复脚本</strong><br>重复脚本会创建不必要的HTTP请求，执行无用的JavaScript代码，而影响页面性能。</p><p><strong>16.减少 DOM 访问</strong><br>用JavaScript访问DOM元素是很慢的，所以应该：<br>缓存已访问过的元素的索引。<br>先“离线”更新节点，再把它们添到DOM树上。<br>避免用JavaScript修复布局问题。<br>参考《如何优化 JavaScript 脚本的性能》提高 Ajax 应用程序性能，避开 Web 服务漏洞。</p><p><strong>17.用智能的事件处理器</strong><br>有时候感觉页面反映不够灵敏，是因为有太多频繁执行的事件处理器被添加到了DOM树的不同元素上，这就是推荐使用事件委托的原因。如果一个div里面有10个按钮，应该只给div容器添加一个事件处理器，而不是给每个按钮都添加一个。事件能够冒泡，所以可以捕获事件并得知哪个按钮是事件源。</p><p><strong>18.脚本放到 HTML 代码页底部</strong><br>当一个脚本在下载的时候，浏览器干不了其它的事儿(串行了)。所以，把它扔到最后面去处理。对于一些功能性的脚本，可能实现起来有些两难。不过对于国内网站来说，有很多使用 Google Analytics 服务进行网站数据分析的。这这一点来说，绝对可行的建议，放到页面最底下。</p><p><strong>19.从页面中剥离 JavaScript 与 CSS</strong><br>用外部文件可以让页面更快，因为JavaScript和CSS文件会被缓存在浏览器。</p><p><strong>20.压缩 JavaScript 与 CSS</strong><br>去除不必要的字符以减少大小，从而提升加载速度。启用了gzip模块。</p><h4 id="4-图像优化"><a href="#4-图像优化" class="headerlink" title="4.图像优化"></a>4.图像优化</h4><p><strong>21.优化图片</strong> (Optimize Images)<br>尽可能的使用 PNG 格式的图片，在考虑用 Pngcrush 或类似的工具进行优化。<br>请设计的同学考虑面向 Web 的图片。</p><p><strong>22.使用 CSS Sprites 技巧对图片优化</strong><br>图片横向排列一般都比纵向排列的最终文件小。<br>图片相似颜色可以保持低色数，最理想的是256色以下PNG8格式。<br>考虑移动端，不要在Sprite图片中留下太大的空隙。虽然不会在很大程度上影响图片文件的大小，但这样做可以节省用户代理把图片解压成像素映射时消耗的内存。<br>一个大k图片就把整个网站拖得很慢。</p><p><strong>23.不要在 HTML 中使用缩放图片</strong><br>不要因为在HTML中可以设置宽高而使用本不需要的大图。</p><p><strong>24.用更小的并且可缓存的 favicon.ico</strong><br>足够小，越小越好。<br>设置合适的有效期HTTP头（以后如果想换的话就不能重命名了），把有效期设置为几个月后一般比较安全，可以通过检查当前favicon.ico的最后修改日期来确保变更能让浏览器知道。</p><h4 id="5-Cookie优化"><a href="#5-Cookie优化" class="headerlink" title="5.Cookie优化"></a>5.Cookie优化</h4><p><strong>25.缩小 Cookie</strong><br>清除不必要的cookie。<br>保证cookie尽可能小，以最小化对用户响应时间的影响。<br>注意给cookie设置合适的域级别，以免影响其它子域。<br>设置合适的有效期，更早的有效期或者none可以更快的删除cookie，提高用户响应时间。</p><p><strong>26.针对 Web 组件使用域名无关性的 Cookie</strong><br>当浏览器发送对静态资源的请求时，cookie也会一起发送，而服务器根本不需要这些cookie。造成没有意义的网络通信量，应该确保对静态组件的请求不含cookie。可以创建一个子域，把所有的静态组件都部署在那儿。<br>Yahoo! 的静态文件都在 yimg.com 上，客户端请求静态文件的时候，减少了 Cookie 的反复传输对主域名 (yahoo.com) 的影响。</p><h4 id="6-移动端优化"><a href="#6-移动端优化" class="headerlink" title="6.移动端优化"></a>6.移动端优化</h4><p><strong>27.保证所有组件都小于25K</strong><br>这个限制是因为iPhone不能缓存大于25K的组件，注意这里指的是未压缩的大小。这就是为什么缩减内容本身也很重要，因为单纯的gzip可能不够。</p><p>Updated: 根据这篇 iPhone caching 的文章，可供 Cache 的最大单个数据对象是 15K，而不是前面说的 25K。iPhone 总的 Cache Size 为 ###5M。浏览器地址栏的刷新按钮将导致无条件刷新所有组件。这些也是挺有趣的。</p><p><strong>28.把组件打包到一个复合文档里</strong><br>把各个组件打包成一个像有附件的电子邮件一样的复合文档里（多部分组成的文档），可以用一个HTTP请求获取多个组件（减少 HTTP 请求）。用这种方式的时候，要先检查用户代理是否支持（iPhone就不支持）。</p><h4 id="7-Server端优化"><a href="#7-Server端优化" class="headerlink" title="7.Server端优化"></a>7.Server端优化</h4><p><strong>29.使用Gzip组件</strong><br>从HTTP/1.1开始，web客户端就有了支持压缩的Accept-Encoding HTTP请求头。(Accept-Encoding: gzip, deflate)。<br>如果web服务器看到这个请求头，它就会用客户端列出的一种方式来压缩响应。web服务器通过Content-Encoding相应头来通知客户端。(Content-Encoding: gzip)</p><p><strong>30.避免图片src属性为空</strong><br>html与JavaScript的src为空，会使浏览器会向服务器发送另一个请求。</p><p><strong>31.设置 Etags</strong><br>实体标签（ETags），是服务器和浏览器用来决定浏览器缓存中组件与源服务器中的组件是否匹配的一种机制(实体即静态资源)。<br>Etag 对多数站点性能的影响并不是很大。除非是面向 RSS 的网站。（IE 的 ETag 注意 IIS事项）<br>很多网站在不注意的情况下都是打开 Etag 的，而没有网站关心如何用，消耗资源而不知。并不是说 Etag 不好，合理利用 Etag ，绝对能取得很好的收益。</p><p><strong>32.对 AJAX 请求使用 GET 方法</strong><br>XMLHttpRequest POST 要两步，先发送HTTP头，在发送数据，而 GET 只需要一步，发送一个TCP报文。但要注意的是在 IE 上 GET 最大能处理的 URL 长度是 2K。</p><p><strong>33.尽早清空缓冲区</strong><br>较理想的清空缓冲区的位置是HEAD后面，因为HTML的HEAD部分通常更容易生成，并且允许引入任何CSS和JavaScript文件，这样就可以让浏览器在后台还在处理的时候就开始并行获取组件。(异步的思路)</p><p><strong>34.使用 CDN</strong><br>最好先分散静态内容，而不是一开始就重新设计应用程序结构。这不仅能够大大减少响应时间，还更容易表现出CDN的功劳。一组分散在不同地理位置的web服务器，用来给用户更高效地发送内容。<br>国内 CDN 的普及还不够。不过我们有独特的电信、网通之间的问题，如果针对这个作优化，基本上也算能收到 CDN 或类似的效果吧(假装如此)。</p><p><strong>35.添加 Expires 或 Cache-Control 信息头</strong><br>对于静态组件：通过设置一个遥远的将来时间作为Expires来实现永不失效。<br>多余动态组件：用合适的Cache-ControlHTTP头来让浏览器进行条件性的请求。<br>Apache、Nginx的相应配置。</p><p><strong>最后使用工具 PageSpeed 一步一步来优化吧。</strong></p><p>参考：<br><a href="https://developer.yahoo.com/performance/" target="_blank" rel="noopener">https://developer.yahoo.com/performance/</a><br><a href="http://ingf.github.io/web/2014/12/10/web-.html" target="_blank" rel="noopener">http://ingf.github.io/web/2014/12/10/web-.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>浏览器工作流程</title>
      <link href="/2016/12/11/browser-work-principle/"/>
      <url>/2016/12/11/browser-work-principle/</url>
      
        <content type="html"><![CDATA[<h2 id="构建对象模型"><a href="#构建对象模型" class="headerlink" title="构建对象模型"></a>构建对象模型</h2><p>浏览器渲染页面前需要先构建对象模型，根据HTML和CSS输入构建了DOM树和CSSOM树，两树合并成渲染树，然后用于计算每个可见元素的布局，并输出给绘制流程，将像素渲染到屏幕上。</p><ul><li>字节 → 字符 → 令牌 → 节点 → 对象模型。(令牌:字符转W3C标准的标签)</li><li>HTML 标记转换成文档对象模型 (DOM)。</li><li>CSS 标记转换成 CSS 对象模型 (CSSOM)。</li><li>DOM 和 CSSOM 是独立的数据结构。（JavaScript可以通过DOM API和CSSOM API来操作两个树）</li><li>Chrome DevTools Timeline 可以捕获 DOM 和 CSSOM 的构建和处理开销。</li></ul><p><img src="/images/0c389301ba794f3ca7b491572d73971d.png" alt="0c389301ba794f3ca7b491572d73971d.png"></p><p>注：建立CSS树是需要比照着DOM树，CSS匹配DOM树从右到左解析CSS的Selector。因为这个过程有性能问题，所以很多人说，DOM树要小，CSS尽量用id和class，千万不要过渡层叠下去等。<br>Render Tree会把一些不可见的结点去除掉。</p><h2 id="构建渲染树、布局及绘制"><a href="#构建渲染树、布局及绘制" class="headerlink" title="构建渲染树、布局及绘制"></a>构建渲染树、布局及绘制</h2><ol><li>计算CSS样式</li><li>构建渲染树（Render Tree)</li><li>布局定位坐标和大小，是否换行，各种position, overflow, z-index属性等（Layout）</li><li>最后一步是绘制，最终渲染树将像素渲染到屏幕上。(Reflow，Repaint)</li></ol><p><strong>Repaint（重绘）</strong>: 屏幕的一部分要重画，如某个CSS的背景色变了，但是元素的几何尺寸没有变。</p><p><strong>Reflow（重排）</strong>: 渲染树的一部分或全部发生了变化，元件的几何尺寸变了，我们需要重新验证并计算渲染树。</p><blockquote><p>HTML使用的流式布局，重排会从<html>这个root frame开始递归往下，依次计算所有的结点几何尺寸和位置，在重排过程中，可能会增加一些frame，比如一个文本字符串必需被包装起来。</html></p></blockquote><p>注：Reflow的成本比Repaint的成本高得多。DOM树里的每个结点都会有reflow方法，一个结点的reflow很有可能导致子结点，甚至父点以及同级结点的reflow。</p><p>所以，下面这些动作有很大可能会是成本比较高的。</p><ul><li>当你增加、删除、修改DOM结点时，会导致Reflow或Repaint</li><li>当你移动DOM的位置，或是搞个动画的时候。</li><li>当你修改CSS样式的时候。</li><li>当你Resize窗口的时候（移动端没有这个问题），或是滚动的时候。</li><li>当你修改网页的默认字体时。</li></ul><p>注：display:none会触发reflow，而visibility:hidden只会触发repaint，因为没有发现位置变化。（前者完全看不见，后者会占着布局）</p><p>如果在滚屏的时候，我们的页面上的所有的像素都会跟着滚动，那么性能上没什么问题，因为我们的显卡对于这种把全屏像素往上往下移的算法是很快。但是如果你有一个fixed的背景图，或是有些Element不跟着滚动，有些Elment是动画，那么这个滚动的动作对于浏览器来说会是相当相当痛苦的一个过程。你可以看到很多这样的网页在滚动的时候性能有多差。因为滚屏也有可能会造成reflow。</p><p>基本上来说，reflow有如下的几个原因：</p><ul><li>Initial。网页初始化的时候。</li><li>Incremental。一些Javascript在操作DOM Tree时。</li><li>Resize。某些元件的尺寸变了。</li><li>StyleChange。如果CSS的属性发生变化了。</li><li>Dirty。几个Incremental的reflow发生在同一个frame的子树上。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bstyle = <span class="built_in">document</span>.body.style; <span class="comment">// cache</span></span><br><span class="line">bstyle.padding = <span class="string">"20px"</span>; <span class="comment">// reflow, repaint</span></span><br><span class="line">bstyle.border = <span class="string">"10px solid red"</span>; <span class="comment">//  再一次的 reflow 和 repaint </span></span><br><span class="line">bstyle.color = <span class="string">"blue"</span>; <span class="comment">// repaint</span></span><br><span class="line">bstyle.backgroundColor = <span class="string">"#fad"</span>; <span class="comment">// repaint</span></span><br><span class="line">bstyle.fontSize = <span class="string">"2em"</span>; <span class="comment">// reflow, repaint </span></span><br><span class="line"><span class="comment">// new DOM element - reflow, repaint</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'dude!'</span>));</span><br></pre></td></tr></table></figure><p>当然，我们的浏览器是聪明的，它不会像上面那样，你每改一次样式，它就reflow或repaint一次。一般来说，浏览器会把这样的操作积攒一批，然后做一次reflow，这又叫异步reflow或增量异步reflow。但是有些情况浏览器是不会这么做的，比如：resize窗口，改变了页面默认的字体，等。对于这些操作，浏览器会马上进行reflow。</p><p>但是有些时候，我们的脚本会阻止浏览器这么干，比如：如果我们请求下面的一些DOM值：</p><ol><li>offsetTop, offsetLeft, offsetWidth, offsetHeight</li><li>scrollTop/Left/Width/Height</li><li>clientTop/Left/Width/Height</li><li>IE中的 getComputedStyle(), 或 currentStyle</li></ol><p>因为，如果我们的程序需要这些值，那么浏览器需要返回最新的值，而这样也会做出一些样式的改变，从而造成频繁的reflow/repaint。</p><h2 id="优化关键渲染路径与性能"><a href="#优化关键渲染路径与性能" class="headerlink" title="优化关键渲染路径与性能"></a>优化关键渲染路径与性能</h2><p>减少reflow/repaint来优化性能：</p><p>1.不要一条一条地修改DOM的样式。可以预先定义好class，然后修改DOM的className。<br>2.把DOM离线后修改</p><ul><li>使用documentFragment 对象在内存里操作DOM</li><li>先把DOM给display:none(有一次reflow)，然后你想怎么改就怎么改。比如修改100次，然后再把他显示出来。</li><li>clone一个DOM结点到内存里，改完后和在线的那个的交换一下。</li></ul><p>3.不要把DOM结点的属性值放在一个循环里当成循环里的变量。会导致大量地读写这个结点的属性。<br>4.尽可能的修改层级比较低的DOM。当然，改变层级比较底的DOM有可能会造成大面积的reflow，但是也可能影响范围很小。<br>5.为动画的HTML元件使用fixed或absoult的position，那么修改他们的CSS是不会reflow的。<br>6.千万不要使用table布局。因为可能很小的一个小改动会造成整个table的重新布局。</p><p><strong>最后简述浏览器工作步骤：</strong></p><ol><li>处理 HTML 标记并构建 DOM 树。</li><li>处理 CSS 标记并构建 CSSOM 树。</li><li>将 DOM 与 CSSOM 合并成一个渲染树。</li><li>根据渲染树来布局，以计算每个节点的几何信息。</li><li>将各个节点绘制到屏幕上。</li><li>我们的演示网页看起来可能很简单，实际上却需要完成相当多的工作。如果 DOM 或 CSSOM 被修改，您只能再执行一遍以上所有步骤，以确定哪些像素需要在屏幕上进行重新渲染。</li></ol><p>参考：<br><a href="https://developers.google.com/speed/docs/insights/rules?csw=1" target="_blank" rel="noopener">https://developers.google.com/speed/docs/insights/rules?csw=1</a><br><a href="https://developer.yahoo.com/performance/rules.html?guccounter=1" target="_blank" rel="noopener">https://developer.yahoo.com/performance/rules.html?guccounter=1</a><br><a href="http://stevesouders.com/hpws/rules.php" target="_blank" rel="noopener">http://stevesouders.com/hpws/rules.php</a><br><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=zh-cn" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=zh-cn</a><br><a href="https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/" target="_blank" rel="noopener">https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/</a><br><a href="https://coolshell.cn/articles/9666.html" target="_blank" rel="noopener">https://coolshell.cn/articles/9666.html</a><br><a href="https://juejin.im/entry/59e1d31f51882578c3411c77" target="_blank" rel="noopener">https://juejin.im/entry/59e1d31f51882578c3411c77</a><br><a href="https://www.jianshu.com/p/d616d887953a" target="_blank" rel="noopener">https://www.jianshu.com/p/d616d887953a</a><br><a href="https://zhuanlan.zhihu.com/p/33149162" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/33149162</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>浏览器缓存机制</title>
      <link href="/2016/11/26/browser-cash-principle/"/>
      <url>/2016/11/26/browser-cash-principle/</url>
      
        <content type="html"><![CDATA[<h4 id="缓存的工作原理"><a href="#缓存的工作原理" class="headerlink" title="缓存的工作原理"></a>缓存的工作原理</h4><p>所有缓存都是由一套规则决定什么时候使用缓存中的副本，这些规则定义在协议中（http1.0/1.1）或由缓存管理员设置（如DBA、浏览器的用户、代理服务器管理员或者应用开发者）。</p><h4 id="浏览器缓存规则"><a href="#浏览器缓存规则" class="headerlink" title="浏览器缓存规则"></a>浏览器缓存规则</h4><p>规则定义在HTTP协议头和HTML页面的Meta标签中。用新鲜度和校验值来规定浏览器是否可以直接使用缓存，还是需要去源服务器获取更新的版本。</p><p><strong>新鲜度（过期机制）</strong>：<br>1.在有效期内的，含有完整的过期时间控制头信息（HTTP协议报头）。<br>2.浏览器已经使用过这个缓存副本，并且在一个会话中已经检查过新鲜度。</p><p><strong>校验值（验证机制）</strong>：<br>服务器返回资源的时候有时在控制头信息带上这个资源的实体标签Etag（Entity Tag），再次请求过程的校验标识。不匹配则被修改或过期了，浏览器需求重新获取资源内容。</p><h4 id="浏览器缓存控制"><a href="#浏览器缓存控制" class="headerlink" title="浏览器缓存控制"></a>浏览器缓存控制</h4><p><strong>使用HTML Meta 标签</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">META</span> <span class="attr">HTTP-EQUIV</span>=<span class="string">"Pragma"</span> <span class="attr">CONTENT</span>=<span class="string">"no-cache"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>页面不被缓存，每次都去服务器拉取。（仅部分浏览器可以支持）</p><p><strong>使用缓存有关的HTTP消息报头</strong><br>一个URI的完整HTTP协议交互过程是由HTTP请求和HTTP响应组成的。在HTTP请求和响应的消息报头中，常见的与缓存有关的消息报头有：<br><img src="/images/f13fbce9ebb19c90b60539e982a383de.png" alt="f13fbce9ebb19c90b60539e982a383de.png"></p><p><strong>Cache-Control与Expires</strong>: 有效期，控制浏览器读缓存还是读服务器。前者配置更多，优先级更高。</p><p><strong>Last-Modified/ETag与Cache-Control/Expires</strong>：<br>前者是先询问服务器是否有更改，没有则返回304读本地缓存，有则返回改过的数据。<br>后者先读本地有效期内缓存，不发请求。优先级更高。<br>一般情况下同时使用，因为即使点击“刷新“忽略缓存继续请求，也会返回304以减少开销。</p><p><strong>Last-Modified与ETag</strong>：<br>HTTP1.1中Etag（实体标识）解决几个Last-Modified比较难解决的问题：<br>1.秒内的新鲜度无法标注。（Last-Modified只到秒级）<br>2.文件内容没变化Last-Modified却变了，无法使用缓存。<br>3.服务器时间不一致。</p><p>Etag是资源在服务器唯一标识符，先验证ETag -&gt; 在对比Last-Modified -&gt; 是否返回304。</p><p><strong>用户操作行为与缓存</strong>：</p><ul><li><p>地址栏回车、页面链接跳转、新开窗口、前进后退，两种缓存设置均有效。</p></li><li><p>刷新：会忽略Expires/Cache-Control的设置，再次发请求，而Last-Modified/Etag还是有效的，服务器会根据情况判断返回304还是200。</p></li><li><p>强制刷新：全失效，重新从服务器拉资源。</p></li></ul><h4 id="哪些请求不能被缓存？"><a href="#哪些请求不能被缓存？" class="headerlink" title="哪些请求不能被缓存？"></a>哪些请求不能被缓存？</h4><ul><li><p>HTTP响应头中不包含Last-Modified/Etag，也不包含Cache-Control/Expires的请求无法被缓存</p></li><li><p>HTTP信息头中包含Cache-Control:no-cache，pragma:no-cache，或Cache-Control:max-age=0等告诉浏览器不用缓存的请求。</p></li><li><p>需要根据Cookie，认证信息等决定输入内容的动态请求是不能被缓存的。</p></li><li><p>POST请求无法被缓存。</p></li><li><p>经过HTTPS安全加密的请求（有人也经过测试发现，ie其实在头部加入Cache-Control：max-age信息，firefox在头部加入Cache-Control:Public之后，能够对HTTPS的资源进行缓存，参考《HTTPS的七个误解》）。</p></li></ul><p>参考：<br><a href="http://www.alloyteam.com/2012/03/web-cache-2-browser-cache/#prettyPhoto" target="_blank" rel="noopener">http://www.alloyteam.com/2012/03/web-cache-2-browser-cache/#prettyPhoto</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Markdown基本用法</title>
      <link href="/2016/10/26/markdown/"/>
      <url>/2016/10/26/markdown/</url>
      
        <content type="html"><![CDATA[<h3 id="Markdown优点"><a href="#Markdown优点" class="headerlink" title="Markdown优点"></a>Markdown优点</h3><p>Markdown是一种轻量级标记语言，它以纯文本形式(易读、易写、易更改)编写文档，并最终以HTML格式发布。</p><ul><li>纯文本，兼容性极强，所有文本编辑器都可打开。</li><li>标记语法可读性强。</li><li>让你专注于文字而不是排版。</li><li>格式转换方便，轻松转换为 html、电子书等。</li><li>摆脱Word。</li><li>跨平台使用。</li><li>越来越多的网站支持Markdown。</li></ul><h3 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h3><h4 id="代码与语法高亮"><a href="#代码与语法高亮" class="headerlink" title="代码与语法高亮"></a>代码与语法高亮</h4><p>代码区块的建立是在每行加上4个空格或者一个制表符（如同写代码一样）</p><pre><code>&lt;php&gt;       echo “不带行号&quot;;&lt;/php&gt;</code></pre><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;php&gt;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'带行号'</span>;</span><br><span class="line">&lt;/php&gt;</span><br></pre></td></tr></table></figure><p> 行内需要引用代码，只要用反引号引起来</p><pre><code>Use the `console.log(&apos;test&apos;)` function.</code></pre><h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><pre><code># 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题</code></pre><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- 无序列表1</span><br><span class="line">- 无序列表2</span><br><span class="line">- 无序列表3</span><br><span class="line"></span><br><span class="line">1. 有序列表1</span><br><span class="line">2. 有序列表2</span><br><span class="line">3. 有序列表3</span><br></pre></td></tr></table></figure><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><pre><code>&gt; 这个是引用</code></pre><h4 id="粗体与斜体"><a href="#粗体与斜体" class="headerlink" title="粗体与斜体"></a>粗体与斜体</h4><pre><code>**这个是粗体***这个是斜体*</code></pre><h4 id="链接与图片"><a href="#链接与图片" class="headerlink" title="链接与图片"></a>链接与图片</h4><p>插入链接</p><pre><code>[link text](http://example.com/ &quot;optional title&quot;)</code></pre><p><a href="http://example.com/" title="optional title" target="_blank" rel="noopener">link text</a></p><pre><code> [link text][id] [id]: http://example.com/  &quot;optional title here&quot;&lt;http://example.com/&gt; or &lt;address@example.com&gt;</code></pre><p>插入图片<br>形式和链接相似，只需在链接的基础上前方加一个</p><pre><code>![alt text](/images/example.png &quot;optional title&quot;)</code></pre><p><img src="/images/4766746846417a2e706e67.png" alt="alt text" title="Fork you"></p><p>图片与链接写法结合</p><pre><code>[![alt text](/images/4766746846417a2e706e67.png &quot;Fork you&quot;)](你的链接地址)</code></pre><h4 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h4><pre><code>半方大的空白&amp;ensp;或&amp;#8194;全方大的空白&amp;emsp;或&amp;#8195;不断行的空白格&amp;nbsp;或&amp;#160;</code></pre><h4 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h4><p>可以在一行中用三个以上的星号、减号、底线来建立一个分隔线</p><hr><h4 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h4><pre><code>~~Mistaken text.~~</code></pre><p><del>Mistaken text.</del></p><h4 id="反斜杠"><a href="#反斜杠" class="headerlink" title="反斜杠\"></a>反斜杠\</h4><p>相当于反转义作用。使符号成为普通符号。</p><h4 id="符号’-’"><a href="#符号’-’" class="headerlink" title="符号’`’"></a>符号’`’</h4><pre><code>`ctrl+a`</code></pre><h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ABCD | EFGH | IGKL</span><br><span class="line">-----|------|----</span><br><span class="line">a    | b    | c</span><br><span class="line">d    | e    | f</span><br><span class="line">g    | h    | i</span><br></pre></td></tr></table></figure><table><thead><tr><th>ABCD</th><th>EFGH</th><th>IGKL</th></tr></thead><tbody><tr><td>a</td><td>b</td><td>c</td></tr><tr><td>d</td><td>e</td><td>f</td></tr><tr><td>g</td><td>h</td><td>i</td></tr></tbody></table><h4 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- [x] @mentions, #refs, [links](), **formatting**, and &lt;del&gt;tags&lt;/del&gt; are supported</span><br><span class="line">- [ ] this is an incomplete item</span><br></pre></td></tr></table></figure><ul><li style="list-style: none"><input type="checkbox" checked> @mentions, #refs, <a href="">links</a>, <strong>formatting</strong>, and <del>tags</del> are supported</li><li style="list-style: none"><input type="checkbox"> this is an incomplete item</li></ul><p>参考：<br><a href="http://younghz.github.io/Markdown/" target="_blank" rel="noopener">http://younghz.github.io/Markdown/</a><br><a href="https://coolshell.cn/articles/11928.html" target="_blank" rel="noopener">https://coolshell.cn/articles/11928.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2016/10/24/hello-world/"/>
      <url>/2016/10/24/hello-world/</url>
      
        <content type="html"><![CDATA[<p>hello world ^_^</p>]]></content>
      
      
      <categories>
          
          <category> 管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 写作 </tag>
            
            <tag> 管理 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
